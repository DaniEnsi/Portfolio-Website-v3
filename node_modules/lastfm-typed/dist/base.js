"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const request_1 = require("./request");
class LFMBase {
    constructor(apiKey, lastfm, apiSecret = "", userAgent = "lastfm-typed-npm", secureConnection = false) {
        this.key = apiKey;
        this.secret = apiSecret;
        this.userAgent = userAgent;
        this.secureConnection = secureConnection;
        this.info = lastfm.info;
    }
    checkLimit(limit, maxLimit) {
        if (typeof limit !== "undefined" && (limit > maxLimit || limit < 1)) {
            throw { message: `Limit out of bounds (1-${maxLimit}), ${limit} passed`, code: 6 };
        }
    }
    checkScrobbleCount(scrobbleCount, maxScrobbleCount) {
        if (typeof scrobbleCount === "undefined" || (scrobbleCount > maxScrobbleCount || scrobbleCount < 1)) {
            throw { message: `Scrobble count out of bounds (1-${maxScrobbleCount}), ${scrobbleCount} passed`, code: 6 };
        }
    }
    convertNumRes(params) {
        let newParams = {
            num_res: 50,
            offset: 0
        };
        newParams.num_res = (params === null || params === void 0 ? void 0 : params.limit) || 50;
        newParams.offset = (((params === null || params === void 0 ? void 0 : params.page) || 1) - 1) * newParams.num_res;
        return newParams;
    }
    convertGetTags(res) {
        if ((res === null || res === void 0 ? void 0 : res["#text"]) === " ") {
            res.tag = [];
            delete res["#text"];
        }
        return res;
    }
    async sendRequest(params) {
        const res = await new request_1.LFMRequest(this.info, this.userAgent, this.secureConnection, params).execute();
        this.info.context.logger.emitRequestComplete(params, res.time, res.res);
        return res.res;
    }
}
exports.default = LFMBase;
//# sourceMappingURL=base.js.map