"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __importDefault(require("../base"));
const caster_1 = require("../caster");
class TrackClass extends base_1.default {
    async addTags(artist, track, tags, sk) {
        artist = (0, caster_1.convertString)(artist, "artist", { track, tags, sk });
        artist.tags = (0, caster_1.joinArray)(artist.tags);
        return await this.sendRequest({ method: "track.addTags", ...artist });
    }
    async getCorrection(artist, track) {
        var _a, _b;
        artist = (0, caster_1.convertString)(artist, "artist", { track });
        let res = (((_b = (_a = (await this.sendRequest({ method: "track.getCorrection", ...artist }))) === null || _a === void 0 ? void 0 : _a.corrections) === null || _b === void 0 ? void 0 : _b.correction) || {});
        if (!res.track.hasOwnProperty("name")) {
            res = {};
        }
        if (Object.keys(res).length) {
            res.meta = (0, caster_1.convertMeta)(res["@attr"]);
            delete res["@attr"];
        }
        return res;
    }
    async getInfo(track, params) {
        var _a, _b;
        let res = (await this.sendRequest({ method: "track.getInfo", ...track, ...params })).track;
        res.toptags = (0, caster_1.toArray)((_a = res.toptags) === null || _a === void 0 ? void 0 : _a.tag);
        res = (0, caster_1.convertEntry)(res);
        if (res.album) {
            if (res.album["@attr"]) {
                res.album.position = (0, caster_1.toInt)((_b = res.album["@attr"]) === null || _b === void 0 ? void 0 : _b.position);
                delete res.album["@attr"];
            }
            res.album.image = (0, caster_1.convertImageArray)(res.album.image);
        }
        return res;
    }
    async getSimilar(track, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : track === null || track === void 0 ? void 0 : track.limit, 1000);
        let res = (await this.sendRequest({ method: "track.getSimilar", ...track, ...params })).similartracks;
        return (0, caster_1.convertExtendedMeta)(res, "track");
    }
    async getTags(track, username, params) {
        track = (0, caster_1.addConditionals)(track, { username });
        let res = this.convertGetTags((await this.sendRequest({ method: "track.getTags", ...track, ...params })).tags);
        return (0, caster_1.convertBasicMetaTag)(res);
    }
    async getTopTags(track, params) {
        let res = (await this.sendRequest({ method: "track.getTopTags", ...track, ...params })).toptags;
        return (0, caster_1.convertBasicMetaTag)(res);
    }
    async love(artist, track, sk) {
        artist = (0, caster_1.convertString)(artist, "artist", { track, sk });
        return await this.sendRequest({ method: "track.love", ...artist });
    }
    async removeTag(artist, track, tag, sk) {
        artist = (0, caster_1.convertString)(artist, "artist", { track, sk, tag });
        return await this.sendRequest({ method: "track.removeTag", ...artist });
    }
    async scrobble(firstInput, scrobbles) {
        firstInput = (0, caster_1.convertString)(firstInput, "sk", { scrobbles });
        this.checkScrobbleCount(firstInput.scrobbles.length, 50);
        let params = {};
        for (let [index, scrobble] of firstInput.scrobbles.entries()) {
            for (let [key, value] of Object.entries(scrobble)) {
                if (value === void 0) {
                    continue;
                }
                if (key === "chosenByUser") {
                    params[`${key}[${index}]`] = (0, caster_1.boolToInt)(value);
                }
                else {
                    params[`${key}[${index}]`] = value;
                }
            }
        }
        let res = (await this.sendRequest({ method: "track.scrobble", ...params, sk: firstInput.sk })).scrobbles;
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        res.scrobbles = (0, caster_1.toArray)(res.scrobble).map((e) => {
            e.ignoredMessage.message = e.ignoredMessage["#text"];
            delete e.ignoredMessage["#text"];
            if (e.artist["#text"]) {
                e.artist.name = e.artist["#text"];
                delete e.artist["#text"];
            }
            if (e.album["#text"]) {
                e.album.name = e.album["#text"];
                delete e.album["#text"];
            }
            if (e.track["#text"]) {
                e.track.name = e.track["#text"];
                delete e.track["#text"];
            }
            if (e.albumArtist["#text"]) {
                e.albumArtist.name = e.albumArtist["#text"];
                delete e.albumArtist["#text"];
            }
            e.artist.corrected = (0, caster_1.toBool)(e.artist.corrected);
            e.album.corrected = (0, caster_1.toBool)(e.album.corrected);
            e.albumArtist.corrected = (0, caster_1.toBool)(e.albumArtist.corrected);
            e.track.corrected = (0, caster_1.toBool)(e.track.corrected);
            e.ignoredMessage.code = (0, caster_1.toInt)(e.ignoredMessage.code);
            e.timestamp = (0, caster_1.toInt)(e.timestamp);
            return e;
        });
        delete res.scrobble;
        return res;
    }
    async search(track, params) {
        var _a;
        track = (0, caster_1.convertString)(track, "track", {});
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : track === null || track === void 0 ? void 0 : track.limit, 1000);
        let res = (await this.sendRequest({ method: "track.search", ...track, ...params })).results;
        res = (0, caster_1.convertSearch)(res);
        res.trackMatches = (0, caster_1.convertEntryArray)(res.trackmatches.track);
        delete res.trackmatches;
        return res;
    }
    async unlove(artist, track, sk) {
        artist = (0, caster_1.convertString)(artist, "artist", { track, sk });
        return await this.sendRequest({ method: "track.unlove", ...artist });
    }
    async updateNowPlaying(artist, track, sk, params) {
        artist = (0, caster_1.convertString)(artist, "artist", { track, sk });
        return await this.sendRequest({ method: "track.updateNowPlaying", ...artist, ...params });
    }
}
exports.default = TrackClass;
//# sourceMappingURL=track.js.map