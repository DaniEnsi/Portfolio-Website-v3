import LastFM from "..";
import * as UserInterface from "../interfaces/userInterface";
import * as HelperInterface from "../interfaces/helperInterface";
import TypedEmitter from "typed-emitter";
interface ScrobbleEmitter {
    start: (meta: {
        totalPages: number;
        count: number;
    }) => void;
    data: (data: {
        data: UserInterface.getRecentTracks;
        completedPages: number;
        totalPages: number;
        progress: number;
    }) => void;
    close: () => void;
    internalDontUse: (data: UserInterface.getRecentTracks | number) => void;
    error: (err: {
        message: string;
        code: number;
    }, intendedPage: number) => void;
}
export default class HelperClass {
    private lastfm;
    constructor(lastfm: LastFM);
    getCombo(username: string, limit: number, params?: {
        sk?: string;
    }): Promise<HelperInterface.getCombo>;
    getCombo(input: HelperInterface.getComboInput): Promise<HelperInterface.getCombo>;
    getNowPlaying(username: string, detailTypes?: ("artist" | "album" | "track")[], params?: {
        sk?: string;
        extended: boolean;
    }): Promise<HelperInterface.getNowPlaying>;
    getNowPlaying(input: HelperInterface.getNowPlayingInput): Promise<HelperInterface.getNowPlaying>;
    getMatchingArtists(user1: string, user2: string, limit: number, period: "overall" | "7day" | "1month" | "3month" | "6month" | "12month"): Promise<HelperInterface.getMatchingArtists>;
    getMatchingArtists(input: HelperInterface.getMatchingArtistsInput): Promise<HelperInterface.getMatchingArtists>;
    ArtistFromMBID: (mbid: string) => {
        mbid: string;
    };
    ArtistFromName: (artist: string) => {
        artist: string;
    };
    AlbumFromMBID: (mbid: string) => {
        mbid: string;
    };
    AlbumFromName: (artist: string, album: string) => {
        artist: string;
        album: string;
    };
    TrackFromMBID: (mbid: string) => {
        mbid: string;
    };
    TrackFromName: (artist: string, track: string) => {
        artist: string;
        track: string;
    };
    cacheScrobbles(user: string, params?: {
        previouslyCached?: number;
        parallelCaches?: number;
        rateLimitTimeout?: number;
    }): TypedEmitter<ScrobbleEmitter>;
    cacheScrobbles(input: HelperInterface.cacheScrobblesInput): TypedEmitter<ScrobbleEmitter>;
    private handleCaching;
    private attemptClose;
    private handleCacheInstance;
    private getIntersection;
    private checkLimit;
    private fetchDetails;
    private homogenizeUserInput;
}
export {};
