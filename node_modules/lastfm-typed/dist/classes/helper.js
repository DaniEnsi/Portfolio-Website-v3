"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const caster_1 = require("../caster");
class HelperClass {
    constructor(lastfm) {
        this.ArtistFromMBID = (mbid) => ({ mbid });
        this.ArtistFromName = (artist) => ({ artist });
        this.AlbumFromMBID = (mbid) => ({ mbid });
        this.AlbumFromName = (artist, album) => ({ artist, album });
        this.TrackFromMBID = (mbid) => ({ mbid });
        this.TrackFromName = (artist, track) => ({ artist, track });
        this.lastfm = lastfm;
    }
    async getCombo(firstInput, limit) {
        var _a;
        firstInput = (0, caster_1.convertString)(firstInput, "user", { limit: Math.min(1000, limit !== null && limit !== void 0 ? limit : 200) });
        let combo = [true, true, true];
        let comboData = [["", 0], ["", 0], ["", 0]];
        let page = 0;
        let nowplaying = false;
        let trueLimit = 1000;
        let image = [];
        while (firstInput.limit > 0 && combo[0] === combo[1] && combo[1] === combo[2] && combo[2] === true) {
            if (firstInput.limit < 1000 && page > 0) {
                trueLimit = firstInput.limit;
                limit = 1000;
            }
            else if (page === 0 && firstInput.limit <= 1000) {
                trueLimit = firstInput.limit;
            }
            page++;
            let res = await this.lastfm.user.getRecentTracks({ ...firstInput, page });
            if (page === 1) {
                comboData[0][0] = res.tracks[0].artist.name;
                comboData[1][0] = res.tracks[0].album.name;
                comboData[2][0] = res.tracks[0].name;
                image = res.tracks[0].image;
                if (comboData[1][0] === "") {
                    combo[1] = false;
                }
            }
            if ((_a = res.tracks[0]) === null || _a === void 0 ? void 0 : _a.nowplaying) {
                nowplaying = true;
                res.tracks = res.tracks.slice(1);
            }
            for (let i = 0; i < trueLimit; i++) {
                if (!combo[0] && !combo[1] && !combo[2]) {
                    break;
                }
                if (combo[0]) {
                    if (comboData[0][0] === res.tracks[Number(i)].artist.name) {
                        comboData[0][1]++;
                    }
                    else {
                        combo[0] = false;
                    }
                }
                if (combo[1]) {
                    if (comboData[1][0] === res.tracks[Number(i)].album.name) {
                        comboData[1][1]++;
                    }
                    else {
                        combo[1] = false;
                    }
                }
                if (combo[2]) {
                    if (comboData[2][0] === res.tracks[Number(i)].name) {
                        comboData[2][1]++;
                    }
                    else {
                        combo[2] = false;
                    }
                }
            }
        }
        return {
            artist: {
                name: comboData[0][0],
                combo: comboData[0][1]
            },
            album: {
                name: comboData[1][0],
                combo: comboData[1][1]
            },
            track: {
                name: comboData[2][0],
                combo: comboData[2][1]
            },
            nowplaying,
            image
        };
    }
    async getNowPlaying(firstInput, detailTypes = [], params = { extended: true }) {
        var _a;
        firstInput = (0, caster_1.convertString)(firstInput, "user", { detailTypes, ...params });
        firstInput = this.homogenizeUserInput(firstInput);
        const curr = await this.lastfm.user.getRecentTracks(firstInput.user, { limit: 1, extended: firstInput.extended });
        const currTrack = curr.tracks[0];
        const artist = currTrack.artist.name;
        const track = currTrack.name;
        const image = currTrack.image;
        const album = (_a = currTrack.album) === null || _a === void 0 ? void 0 : _a.name;
        const url = currTrack.url;
        const username = curr.meta.user;
        const nowplaying = currTrack === null || currTrack === void 0 ? void 0 : currTrack.nowplaying;
        const details = {
            recent: {
                data: curr
            },
            artist: {
                successful: false
            },
            album: {
                successful: false
            },
            track: {
                successful: false
            }
        };
        if (firstInput.detailTypes) {
            const res = await this.fetchDetails(firstInput.user, firstInput.detailTypes, artist, album, track);
            const exists = res.map((e) => typeof e !== "undefined" && typeof e.error === "undefined");
            let i = 0;
            if (firstInput.detailTypes.includes("artist")) {
                details.artist.data = res[i];
                details.artist.successful = exists[i];
                i++;
            }
            if (firstInput.detailTypes.includes("album") && album) {
                details.album.data = res[i];
                details.album.successful = exists[i];
                i++;
            }
            if (firstInput.detailTypes.includes("track")) {
                details.track.data = res[i];
                details.track.successful = exists[i];
                i++;
            }
            return {
                recent: {
                    artist,
                    album,
                    track,
                    image,
                    url,
                    username,
                    nowplaying
                },
                details
            };
        }
        return {
            recent: {
                artist,
                album,
                track,
                image,
                url,
                username,
                nowplaying
            },
            details: {
                recent: {
                    data: curr
                },
                artist: {
                    successful: false
                },
                album: {
                    successful: false
                },
                track: {
                    successful: false
                },
            }
        };
    }
    async getMatchingArtists(firstInput, user2, limit, period) {
        firstInput = (0, caster_1.convertString)(firstInput, "user1", { user2, limit, period });
        this.checkLimit(firstInput.limit, 1000);
        let request = [
            this.lastfm.user.getTopArtists(firstInput.user1, { limit: firstInput.limit, period: firstInput.period }),
            this.lastfm.user.getTopArtists(firstInput.user2, { limit: firstInput.limit, period: firstInput.period })
        ];
        const res = await Promise.all(request);
        return this.getIntersection(res[0].artists, res[1].artists);
    }
    cacheScrobbles(user, params) {
        params !== null && params !== void 0 ? params : (params = {});
        if (typeof user !== "string") {
            params.previouslyCached = user.previouslyCached;
            params.parallelCaches = user.parallelCaches;
            params.rateLimitTimeout = user.rateLimitTimeout;
            user = user.user;
        }
        let scrobbleEmitter = new events_1.EventEmitter();
        this.handleCaching(user, scrobbleEmitter, params);
        return scrobbleEmitter;
    }
    async handleCaching(user, scrobbleEmitter, params) {
        let count;
        try {
            count = (await this.lastfm.user.getRecentTracks(user, { limit: 1 })).meta.total;
        }
        catch {
            let rateLimitInterval = setInterval(() => {
                try {
                    this.handleCaching(user, scrobbleEmitter, params);
                    clearInterval(rateLimitInterval);
                }
                catch (err) {
                    // ignore this. Why? I forgot
                }
            });
            return;
        }
        let newCount = count - ((params === null || params === void 0 ? void 0 : params.previouslyCached) || 0);
        let totalPages = Math.ceil(newCount / 1000);
        let rateLimited = false;
        let limitTime = (params === null || params === void 0 ? void 0 : params.rateLimitTimeout) || 300000;
        scrobbleEmitter.emit("start", { totalPages, count: newCount });
        let pages = Array(totalPages).fill("").map((_, i) => i + 1);
        let active = Math.min((params === null || params === void 0 ? void 0 : params.parallelCaches) || 1, totalPages);
        let complete = 0;
        this.attemptClose(active, scrobbleEmitter);
        for (let currPage = 1; currPage <= active; currPage++) {
            pages.shift();
            this.handleCacheInstance(user, scrobbleEmitter, currPage, newCount);
        }
        scrobbleEmitter.on("internalDontUse", (data) => {
            if (typeof data !== "number") {
                complete++;
                let data2 = data;
                if (data2.meta.page === totalPages) {
                    data2.tracks = data2.tracks.slice(0, newCount % 1000);
                }
                scrobbleEmitter.emit("data", { data: data2, completedPages: complete, totalPages, progress: complete / totalPages });
                if (pages.length) {
                    if (!rateLimited) {
                        this.handleCacheInstance(user, scrobbleEmitter, pages[0], newCount);
                        pages.shift();
                    }
                    else {
                        let rateLimitInterval = setInterval(() => {
                            if (!rateLimited) {
                                this.handleCacheInstance(user, scrobbleEmitter, pages[0], newCount);
                                pages.shift();
                                clearInterval(rateLimitInterval);
                            }
                        });
                    }
                }
                else {
                    active--;
                    this.attemptClose(active, scrobbleEmitter);
                }
            }
            else {
                if (!rateLimited) {
                    this.handleCacheInstance(user, scrobbleEmitter, data, newCount);
                }
                else {
                    let rateLimitInterval = setInterval(() => {
                        if (!rateLimited) {
                            this.handleCacheInstance(user, scrobbleEmitter, data, newCount);
                            clearInterval(rateLimitInterval);
                        }
                    });
                }
            }
        });
        scrobbleEmitter.on("error", (err, page) => {
            if ((0, caster_1.toInt)(err.code) === 29) {
                rateLimited = true;
                setTimeout(() => {
                    rateLimited = false;
                }, limitTime);
            }
            scrobbleEmitter.emit("internalDontUse", page);
        });
    }
    attemptClose(active, scrobbleEmitter) {
        if (active === 0) {
            scrobbleEmitter.emit("close");
            scrobbleEmitter.removeAllListeners();
        }
    }
    async handleCacheInstance(user, scrobbleEmitter, page, count) {
        var _a;
        try {
            let res = await this.lastfm.user.getRecentTracks(user, { limit: 1000, page });
            if (res.tracks[0].nowplaying) {
                (_a = res === null || res === void 0 ? void 0 : res.tracks) === null || _a === void 0 ? void 0 : _a.shift();
            }
            scrobbleEmitter.emit("internalDontUse", res);
        }
        catch (err) {
            if (typeof err === "object" && err !== null && err.hasOwnProperty("code") && err.hasOwnProperty("message")) {
                scrobbleEmitter.emit("error", {
                    code: Number(err.code),
                    message: err.message
                }, page);
            }
            else {
                scrobbleEmitter.emit("error", {
                    code: 41,
                    message: `An unknown error occurred. Details: ${err}`
                }, page);
            }
        }
    }
    getIntersection(arr1, arr2) {
        const aSort = arr1.sort((a, b) => a.name.localeCompare(b.name));
        const bSort = arr2.sort((a, b) => a.name.localeCompare(b.name));
        let i1 = 0;
        let i2 = 0;
        let common = [];
        while (i1 < aSort.length && i2 < bSort.length) {
            const compare = aSort[i1].name.localeCompare(bSort[i2].name);
            if (compare === 0) {
                common.push({
                    name: aSort[i1].name,
                    url: aSort[i1].url,
                    playcount: [aSort[i1].playcount, bSort[i2].playcount]
                });
                i1++;
                i2++;
            }
            else {
                i1 += +(compare < 0);
                i2 += +(compare > 0);
            }
        }
        return common;
    }
    checkLimit(limit, maxLimit) {
        if (typeof limit !== "undefined" && (limit > maxLimit || limit < 1)) {
            throw new Error(`Limit out of bounds (1-${maxLimit}), ${limit} passed`);
        }
    }
    async fetchDetails(username, detailTypes, artist, album, track, params) {
        let promises = [];
        let options = {
            username
        };
        if (params === null || params === void 0 ? void 0 : params.sk) {
            options.sk = params.sk;
        }
        if (detailTypes === null || detailTypes === void 0 ? void 0 : detailTypes.includes("artist")) {
            promises.push(this.lastfm.artist.getInfo({ artist }, options).catch((err) => { }));
        }
        if ((detailTypes === null || detailTypes === void 0 ? void 0 : detailTypes.includes("album")) && album) {
            promises.push(this.lastfm.album.getInfo({ artist, album }, options).catch((err) => { }));
        }
        if (detailTypes === null || detailTypes === void 0 ? void 0 : detailTypes.includes("track")) {
            promises.push(this.lastfm.track.getInfo({ artist, track }, options).catch((err) => { }));
        }
        return await Promise.all(promises);
    }
    homogenizeUserInput(input) {
        if (input.hasOwnProperty("user")) {
            return input;
        }
        for (let userInput of ["username", "sk", "usernameOrSessionKey"]) {
            if (input.hasOwnProperty(userInput)) {
                input.user = input[userInput];
                delete input[userInput];
            }
        }
        throw "No valid user input";
    }
}
exports.default = HelperClass;
//# sourceMappingURL=helper.js.map