import "./chunk-S5KM4IGW.js";

// node_modules/vue-tippy/dist/vue-tippy.esm.js
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined";
var timeoutDuration = function() {
  var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();
function microtaskDebounce(fn) {
  var called = false;
  return function() {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function() {
      called = false;
      fn();
    });
  };
}
function taskDebounce(fn) {
  var scheduled = false;
  return function() {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function() {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}
var supportsMicroTasks = isBrowser && window.Promise;
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
}
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  var window2 = element.ownerDocument.defaultView;
  var css2 = window2.getComputedStyle(element, null);
  return property ? css2[property] : css2;
}
function getParentNode(element) {
  if (element.nodeName === "HTML") {
    return element;
  }
  return element.parentNode || element.host;
}
function getScrollParent(element) {
  if (!element) {
    return document.body;
  }
  switch (element.nodeName) {
    case "HTML":
    case "BODY":
      return element.ownerDocument.body;
    case "#document":
      return element.body;
  }
  var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }
  return getScrollParent(getParentNode(element));
}
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}
var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
function isIE(version2) {
  if (version2 === 11) {
    return isIE11;
  }
  if (version2 === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }
  var noOffsetParent = isIE(10) ? document.body : null;
  var offsetParent = element.offsetParent || null;
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }
  var nodeName = offsetParent && offsetParent.nodeName;
  if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }
  if (["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
    return getOffsetParent(offsetParent);
  }
  return offsetParent;
}
function isOffsetContainer(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY") {
    return false;
  }
  return nodeName === "HTML" || getOffsetParent(element.firstElementChild) === element;
}
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }
  return node;
}
function findCommonOffsetParent(element1, element2) {
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;
  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }
    return getOffsetParent(commonAncestorContainer);
  }
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top";
  var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }
  return element[upperSide];
}
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var scrollTop = getScroll(element, "top");
  var scrollLeft = getScroll(element, "left");
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
function getBordersSize(styles, axis) {
  var sideA = axis === "x" ? "Left" : "Top";
  var sideB = sideA === "Left" ? "Right" : "Bottom";
  return parseFloat(styles["border" + sideA + "Width"]) + parseFloat(styles["border" + sideB + "Width"]);
}
function getSize(axis, body, html, computedStyle) {
  return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]) : 0);
}
function getWindowSizes(document2) {
  var body = document2.body;
  var html = document2.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize("Height", body, html, computedStyle),
    width: getSize("Width", body, html, computedStyle)
  };
}
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var defineProperty = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _extends = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
function getBoundingClientRect(element) {
  var rect = {};
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, "top");
      var scrollLeft = getScroll(element, "left");
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {
  }
  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };
  var sizes = element.nodeName === "HTML" ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, "x");
    vertScrollbar -= getBordersSize(styles, "y");
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }
  return getClientRect(result);
}
function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isIE102 = isIE(10);
  var isHTML = parent.nodeName === "HTML";
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;
  if (!isIE102 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }
  if (isIE102 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== "BODY") {
    offsets = includeScroll(offsets, parent);
  }
  return offsets;
}
function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, "left") : 0;
  var offset2 = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width,
    height
  };
  return getClientRect(offset2);
}
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    return false;
  }
  if (getStyleComputedProperty(element, "position") === "fixed") {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}
function getFixedPositionOffsetParent(element) {
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, "transform") === "none") {
    el = el.parentElement;
  }
  return el || document.documentElement;
}
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  if (boundariesElement === "viewport") {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    var boundariesNode = void 0;
    if (boundariesElement === "scrollParent") {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === "BODY") {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === "window") {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }
    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
    if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument), height = _getWindowSizes.height, width = _getWindowSizes.width;
      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      boundaries = offsets;
    }
  }
  padding = padding || 0;
  var isPaddingNumber = typeof padding === "number";
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}
function getArea(_ref) {
  var width = _ref.width, height = _ref.height;
  return width * height;
}
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
  if (placement.indexOf("auto") === -1) {
    return placement;
  }
  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function(key) {
    return _extends({
      key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function(a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function(_ref2) {
    var width = _ref2.width, height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split("-")[1];
  return computedPlacement + (variation ? "-" + variation : "");
}
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
function getOuterSizes(element) {
  var window2 = element.ownerDocument.defaultView;
  var styles = window2.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}
function getOppositePlacement(placement) {
  var hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split("-")[0];
  var popperRect = getOuterSizes(popper);
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };
  var isHoriz = ["right", "left"].indexOf(placement) !== -1;
  var mainSide = isHoriz ? "top" : "left";
  var secondarySide = isHoriz ? "left" : "top";
  var measurement = isHoriz ? "height" : "width";
  var secondaryMeasurement = !isHoriz ? "height" : "width";
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }
  return popperOffsets;
}
function find(arr, check) {
  if (Array.prototype.find) {
    return arr.find(check);
  }
  return arr.filter(check)[0];
}
function findIndex(arr, prop, value) {
  if (Array.prototype.findIndex) {
    return arr.findIndex(function(cur) {
      return cur[prop] === value;
    });
  }
  var match = find(arr, function(obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
function runModifiers(modifiers2, data2, ends) {
  var modifiersToRun = ends === void 0 ? modifiers2 : modifiers2.slice(0, findIndex(modifiers2, "name", ends));
  modifiersToRun.forEach(function(modifier) {
    if (modifier["function"]) {
      console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
    }
    var fn = modifier["function"] || modifier.fn;
    if (modifier.enabled && isFunction(fn)) {
      data2.offsets.popper = getClientRect(data2.offsets.popper);
      data2.offsets.reference = getClientRect(data2.offsets.reference);
      data2 = fn(data2, modifier);
    }
  });
  return data2;
}
function update() {
  if (this.state.isDestroyed) {
    return;
  }
  var data2 = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };
  data2.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
  data2.placement = computeAutoPlacement(this.options.placement, data2.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
  data2.originalPlacement = data2.placement;
  data2.positionFixed = this.options.positionFixed;
  data2.offsets.popper = getPopperOffsets(this.popper, data2.offsets.reference, data2.placement);
  data2.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
  data2 = runModifiers(this.modifiers, data2);
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data2);
  } else {
    this.options.onUpdate(data2);
  }
}
function isModifierEnabled(modifiers2, modifierName) {
  return modifiers2.some(function(_ref) {
    var name = _ref.name, enabled2 = _ref.enabled;
    return enabled2 && name === modifierName;
  });
}
function getSupportedPropertyName(property) {
  var prefixes = [false, "ms", "Webkit", "Moz", "O"];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? "" + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== "undefined") {
      return toCheck;
    }
  }
  return null;
}
function destroy() {
  this.state.isDestroyed = true;
  if (isModifierEnabled(this.modifiers, "applyStyle")) {
    this.popper.removeAttribute("x-placement");
    this.popper.style.position = "";
    this.popper.style.top = "";
    this.popper.style.left = "";
    this.popper.style.right = "";
    this.popper.style.bottom = "";
    this.popper.style.willChange = "";
    this.popper.style[getSupportedPropertyName("transform")] = "";
  }
  this.disableEventListeners();
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}
function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === "BODY";
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });
  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}
function setupEventListeners(reference, options, state, updateBound) {
  state.updateBound = updateBound;
  getWindow(reference).addEventListener("resize", state.updateBound, { passive: true });
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
function removeEventListeners(reference, state) {
  getWindow(reference).removeEventListener("resize", state.updateBound);
  state.scrollParents.forEach(function(target) {
    target.removeEventListener("scroll", state.updateBound);
  });
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
function isNumeric(n) {
  return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
}
function setStyles(element, styles) {
  Object.keys(styles).forEach(function(prop) {
    var unit = "";
    if (["width", "height", "top", "right", "bottom", "left"].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = "px";
    }
    element.style[prop] = styles[prop] + unit;
  });
}
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function(prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
function applyStyle(data2) {
  setStyles(data2.instance.popper, data2.styles);
  setAttributes(data2.instance.popper, data2.attributes);
  if (data2.arrowElement && Object.keys(data2.arrowStyles).length) {
    setStyles(data2.arrowElement, data2.arrowStyles);
  }
  return data2;
}
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute("x-placement", placement);
  setStyles(popper, { position: options.positionFixed ? "fixed" : "absolute" });
  return options;
}
function getRoundedOffsets(data2, shouldRound) {
  var _data$offsets = data2.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var round = Math.round, floor = Math.floor;
  var noRound = function noRound2(v) {
    return v;
  };
  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ["left", "right"].indexOf(data2.placement) !== -1;
  var isVariation = data2.placement.indexOf("-") !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}
var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
function computeStyle(data2, options) {
  var x = options.x, y = options.y;
  var popper = data2.offsets.popper;
  var legacyGpuAccelerationOption = find(data2.instance.modifiers, function(modifier) {
    return modifier.name === "applyStyle";
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== void 0) {
    console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== void 0 ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data2.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);
  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data2, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === "bottom" ? "top" : "bottom";
  var sideB = y === "right" ? "left" : "right";
  var prefixedProperty = getSupportedPropertyName("transform");
  var left = void 0, top = void 0;
  if (sideA === "bottom") {
    if (offsetParent.nodeName === "HTML") {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === "right") {
    if (offsetParent.nodeName === "HTML") {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = "transform";
  } else {
    var invertTop = sideA === "bottom" ? -1 : 1;
    var invertLeft = sideB === "right" ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ", " + sideB;
  }
  var attributes = {
    "x-placement": data2.placement
  };
  data2.attributes = _extends({}, attributes, data2.attributes);
  data2.styles = _extends({}, styles, data2.styles);
  data2.arrowStyles = _extends({}, data2.offsets.arrow, data2.arrowStyles);
  return data2;
}
function isModifierRequired(modifiers2, requestingName, requestedName) {
  var requesting = find(modifiers2, function(_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers2.some(function(modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });
  if (!isRequired) {
    var _requesting = "`" + requestingName + "`";
    var requested = "`" + requestedName + "`";
    console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
  }
  return isRequired;
}
function arrow(data2, options) {
  var _data$offsets$arrow;
  if (!isModifierRequired(data2.instance.modifiers, "arrow", "keepTogether")) {
    return data2;
  }
  var arrowElement = options.element;
  if (typeof arrowElement === "string") {
    arrowElement = data2.instance.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return data2;
    }
  } else {
    if (!data2.instance.popper.contains(arrowElement)) {
      console.warn("WARNING: `arrow.element` must be child of its popper element!");
      return data2;
    }
  }
  var placement = data2.placement.split("-")[0];
  var _data$offsets = data2.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var isVertical = ["left", "right"].indexOf(placement) !== -1;
  var len = isVertical ? "height" : "width";
  var sideCapitalized = isVertical ? "Top" : "Left";
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? "left" : "top";
  var opSide = isVertical ? "bottom" : "right";
  var arrowElementSize = getOuterSizes(arrowElement)[len];
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data2.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data2.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data2.offsets.popper = getClientRect(data2.offsets.popper);
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
  var css2 = getStyleComputedProperty(data2.instance.popper);
  var popperMarginSide = parseFloat(css2["margin" + sideCapitalized]);
  var popperBorderSide = parseFloat(css2["border" + sideCapitalized + "Width"]);
  var sideValue = center - data2.offsets.popper[side] - popperMarginSide - popperBorderSide;
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data2.arrowElement = arrowElement;
  data2.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
  return data2;
}
function getOppositeVariation(variation) {
  if (variation === "end") {
    return "start";
  } else if (variation === "start") {
    return "end";
  }
  return variation;
}
var placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
var validPlacements = placements.slice(3);
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}
var BEHAVIORS = {
  FLIP: "flip",
  CLOCKWISE: "clockwise",
  COUNTERCLOCKWISE: "counterclockwise"
};
function flip(data2, options) {
  if (isModifierEnabled(data2.instance.modifiers, "inner")) {
    return data2;
  }
  if (data2.flipped && data2.placement === data2.originalPlacement) {
    return data2;
  }
  var boundaries = getBoundaries(data2.instance.popper, data2.instance.reference, options.padding, options.boundariesElement, data2.positionFixed);
  var placement = data2.placement.split("-")[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data2.placement.split("-")[1] || "";
  var flipOrder = [];
  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }
  flipOrder.forEach(function(step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data2;
    }
    placement = data2.placement.split("-")[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data2.offsets.popper;
    var refOffsets = data2.offsets.reference;
    var floor = Math.floor;
    var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
    var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === "start" && overflowsRight || isVertical && variation === "end" && overflowsLeft || !isVertical && variation === "start" && overflowsBottom || !isVertical && variation === "end" && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      data2.flipped = true;
      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }
      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }
      data2.placement = placement + (variation ? "-" + variation : "");
      data2.offsets.popper = _extends({}, data2.offsets.popper, getPopperOffsets(data2.instance.popper, data2.offsets.reference, data2.placement));
      data2 = runModifiers(data2.instance.modifiers, data2, "flip");
    }
  });
  return data2;
}
function keepTogether(data2) {
  var _data$offsets = data2.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var placement = data2.placement.split("-")[0];
  var floor = Math.floor;
  var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
  var side = isVertical ? "right" : "bottom";
  var opSide = isVertical ? "left" : "top";
  var measurement = isVertical ? "width" : "height";
  if (popper[side] < floor(reference[opSide])) {
    data2.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data2.offsets.popper[opSide] = floor(reference[side]);
  }
  return data2;
}
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];
  if (!value) {
    return str;
  }
  if (unit.indexOf("%") === 0) {
    var element = void 0;
    switch (unit) {
      case "%p":
        element = popperOffsets;
        break;
      case "%":
      case "%r":
      default:
        element = referenceOffsets;
    }
    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === "vh" || unit === "vw") {
    var size = void 0;
    if (unit === "vh") {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    return value;
  }
}
function parseOffset(offset2, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];
  var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;
  var fragments = offset2.split(/(\+|\-)/).map(function(frag) {
    return frag.trim();
  });
  var divider = fragments.indexOf(find(fragments, function(frag) {
    return frag.search(/,|\s/) !== -1;
  }));
  if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
    console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
  }
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
  ops = ops.map(function(op, index) {
    var measurement = (index === 1 ? !useHeight : useHeight) ? "height" : "width";
    var mergeWithPrevious = false;
    return op.reduce(function(a, b) {
      if (a[a.length - 1] === "" && ["+", "-"].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, []).map(function(str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });
  ops.forEach(function(op, index) {
    op.forEach(function(frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1);
      }
    });
  });
  return offsets;
}
function offset(data2, _ref) {
  var offset2 = _ref.offset;
  var placement = data2.placement, _data$offsets = data2.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var basePlacement = placement.split("-")[0];
  var offsets = void 0;
  if (isNumeric(+offset2)) {
    offsets = [+offset2, 0];
  } else {
    offsets = parseOffset(offset2, popper, reference, basePlacement);
  }
  if (basePlacement === "left") {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === "right") {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === "top") {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === "bottom") {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }
  data2.popper = popper;
  return data2;
}
function preventOverflow(data2, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data2.instance.popper);
  if (data2.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }
  var transformProp = getSupportedPropertyName("transform");
  var popperStyles = data2.instance.popper.style;
  var top = popperStyles.top, left = popperStyles.left, transform = popperStyles[transformProp];
  popperStyles.top = "";
  popperStyles.left = "";
  popperStyles[transformProp] = "";
  var boundaries = getBoundaries(data2.instance.popper, data2.instance.reference, options.padding, boundariesElement, data2.positionFixed);
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data2.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === "right" ? "left" : "top";
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function(placement) {
    var side = ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
    popper = _extends({}, popper, check[side](placement));
  });
  data2.offsets.popper = popper;
  return data2;
}
function shift(data2) {
  var placement = data2.placement;
  var basePlacement = placement.split("-")[0];
  var shiftvariation = placement.split("-")[1];
  if (shiftvariation) {
    var _data$offsets = data2.offsets, reference = _data$offsets.reference, popper = _data$offsets.popper;
    var isVertical = ["bottom", "top"].indexOf(basePlacement) !== -1;
    var side = isVertical ? "left" : "top";
    var measurement = isVertical ? "width" : "height";
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data2.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }
  return data2;
}
function hide(data2) {
  if (!isModifierRequired(data2.instance.modifiers, "hide", "preventOverflow")) {
    return data2;
  }
  var refRect = data2.offsets.reference;
  var bound = find(data2.instance.modifiers, function(modifier) {
    return modifier.name === "preventOverflow";
  }).boundaries;
  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    if (data2.hide === true) {
      return data2;
    }
    data2.hide = true;
    data2.attributes["x-out-of-boundaries"] = "";
  } else {
    if (data2.hide === false) {
      return data2;
    }
    data2.hide = false;
    data2.attributes["x-out-of-boundaries"] = false;
  }
  return data2;
}
function inner(data2) {
  var placement = data2.placement;
  var basePlacement = placement.split("-")[0];
  var _data$offsets = data2.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;
  var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;
  popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
  data2.placement = getOppositePlacement(placement);
  data2.offsets.popper = getClientRect(popper);
  return data2;
}
var modifiers = {
  shift: {
    order: 100,
    enabled: true,
    fn: shift
  },
  offset: {
    order: 200,
    enabled: true,
    fn: offset,
    offset: 0
  },
  preventOverflow: {
    order: 300,
    enabled: true,
    fn: preventOverflow,
    priority: ["left", "right", "top", "bottom"],
    padding: 5,
    boundariesElement: "scrollParent"
  },
  keepTogether: {
    order: 400,
    enabled: true,
    fn: keepTogether
  },
  arrow: {
    order: 500,
    enabled: true,
    fn: arrow,
    element: "[x-arrow]"
  },
  flip: {
    order: 600,
    enabled: true,
    fn: flip,
    behavior: "flip",
    padding: 5,
    boundariesElement: "viewport",
    flipVariations: false,
    flipVariationsByContent: false
  },
  inner: {
    order: 700,
    enabled: false,
    fn: inner
  },
  hide: {
    order: 800,
    enabled: true,
    fn: hide
  },
  computeStyle: {
    order: 850,
    enabled: true,
    fn: computeStyle,
    gpuAcceleration: true,
    x: "bottom",
    y: "right"
  },
  applyStyle: {
    order: 900,
    enabled: true,
    fn: applyStyle,
    onLoad: applyStyleOnLoad,
    gpuAcceleration: void 0
  }
};
var Defaults = {
  placement: "bottom",
  positionFixed: false,
  eventsEnabled: true,
  removeOnDestroy: false,
  onCreate: function onCreate() {
  },
  onUpdate: function onUpdate() {
  },
  modifiers
};
var Popper = function() {
  function Popper2(reference, popper) {
    var _this = this;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    classCallCheck(this, Popper2);
    this.scheduleUpdate = function() {
      return requestAnimationFrame(_this.update);
    };
    this.update = debounce(this.update.bind(this));
    this.options = _extends({}, Popper2.Defaults, options);
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper2.Defaults.modifiers, options.modifiers)).forEach(function(name) {
      _this.options.modifiers[name] = _extends({}, Popper2.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });
    this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
      return _extends({
        name
      }, _this.options.modifiers[name]);
    }).sort(function(a, b) {
      return a.order - b.order;
    });
    this.modifiers.forEach(function(modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });
    this.update();
    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      this.enableEventListeners();
    }
    this.state.eventsEnabled = eventsEnabled;
  }
  createClass(Popper2, [{
    key: "update",
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: "destroy",
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: "enableEventListeners",
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: "disableEventListeners",
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
  }]);
  return Popper2;
}();
Popper.Utils = (typeof window !== "undefined" ? window : window).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
var css = '.tippy-iOS{cursor:pointer!important;-webkit-tap-highlight-color:transparent}.tippy-popper{transition-timing-function:cubic-bezier(.165,.84,.44,1);max-width:calc(100% - 8px);pointer-events:none;outline:0}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-7px;bottom:-6.5px;-webkit-transform-origin:50% 0;transform-origin:50% 0;margin:0 3px}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;bottom:-7px;margin:0 3px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 25%;transform-origin:0 25%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-55%);transform:scale(1) translate(-50%,-55%)}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%,-45%);transform:scale(.2) translate(-50%,-45%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(-10px);transform:perspective(700px) translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(60deg);transform:perspective(700px) rotateX(60deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=top] [data-animation=scale]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px) scale(.5);transform:translateY(-10px) scale(.5)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-7px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;margin:0 3px}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;top:-7px;margin:0 3px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -50%;transform-origin:0 -50%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-45%);transform:scale(1) translate(-50%,-45%)}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%);transform:scale(.2) translate(-50%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(10px);transform:perspective(700px) translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(-60deg);transform:perspective(700px) rotateX(-60deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=scale]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px) scale(.5);transform:translateY(10px) scale(.5)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:50% 0 0 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-12px;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%;margin:3px 0}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;right:-7px;margin:3px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-75%,-50%);transform:scale(.2) translate(-75%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(-10px);transform:perspective(700px) translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(-60deg);transform:perspective(700px) rotateY(-60deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=left] [data-animation=scale]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px) scale(.5);transform:translateX(-10px) scale(.5)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 50% 50% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-12px;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%;margin:3px 0}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;left:-7px;margin:3px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-25%,-50%);transform:scale(.2) translate(-25%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(10px);transform:perspective(700px) translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(60deg);transform:perspective(700px) rotateY(60deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=right] [data-animation=scale]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px) scale(.5);transform:translateX(10px) scale(.5)}.tippy-tooltip{position:relative;color:#fff;border-radius:.25rem;font-size:.875rem;padding:.3125rem .5625rem;line-height:1.4;text-align:center;background-color:#333}.tippy-tooltip[data-size=small]{padding:.1875rem .375rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.375rem .75rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:initial}.tippy-tooltip[data-interactive],.tippy-tooltip[data-interactive] .tippy-roundarrow path{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:18px;height:7px;fill:#333;pointer-events:none}.tippy-backdrop{position:absolute;background-color:#333;border-radius:50%;width:calc(110% + 2rem);left:50%;top:50%;z-index:-1;transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:"";float:left;padding-top:100%}.tippy-backdrop+.tippy-content{transition-property:opacity;will-change:opacity}.tippy-backdrop+.tippy-content[data-state=hidden]{opacity:0}';
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var version = "4.3.5";
var isBrowser$1 = typeof window !== "undefined" && typeof document !== "undefined";
var ua = isBrowser$1 ? navigator.userAgent : "";
var isIE$1 = /MSIE |Trident\//.test(ua);
var isUCBrowser = /UCBrowser\//.test(ua);
var isIOS = isBrowser$1 && /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream;
var defaultProps = {
  a11y: true,
  allowHTML: true,
  animateFill: true,
  animation: "shift-away",
  appendTo: function appendTo() {
    return document.body;
  },
  aria: "describedby",
  arrow: false,
  arrowType: "sharp",
  boundary: "scrollParent",
  content: "",
  delay: 0,
  distance: 10,
  duration: [325, 275],
  flip: true,
  flipBehavior: "flip",
  flipOnUpdate: false,
  followCursor: false,
  hideOnClick: true,
  ignoreAttributes: false,
  inertia: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  lazy: true,
  maxWidth: 350,
  multiple: false,
  offset: 0,
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  placement: "top",
  popperOptions: {},
  role: "tooltip",
  showOnInit: false,
  size: "regular",
  sticky: false,
  target: "",
  theme: "dark",
  touch: true,
  touchHold: false,
  trigger: "mouseenter focus",
  triggerTarget: null,
  updateDuration: 0,
  wait: null,
  zIndex: 9999
};
var POPPER_INSTANCE_DEPENDENCIES = ["arrow", "arrowType", "boundary", "distance", "flip", "flipBehavior", "flipOnUpdate", "offset", "placement", "popperOptions"];
var elementProto = isBrowser$1 ? Element.prototype : {};
var matches = elementProto.matches || elementProto.matchesSelector || elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector;
function arrayFrom(value) {
  return [].slice.call(value);
}
function closest(element, selector) {
  return closestCallback(element, function(el) {
    return matches.call(el, selector);
  });
}
function closestCallback(element, callback) {
  while (element) {
    if (callback(element)) {
      return element;
    }
    element = element.parentElement;
  }
  return null;
}
var PASSIVE = {
  passive: true
};
var PADDING = 4;
var PLACEMENT_ATTRIBUTE = "x-placement";
var OUT_OF_BOUNDARIES_ATTRIBUTE = "x-out-of-boundaries";
var IOS_CLASS = "tippy-iOS";
var ACTIVE_CLASS = "tippy-active";
var POPPER_CLASS = "tippy-popper";
var TOOLTIP_CLASS = "tippy-tooltip";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var ROUND_ARROW_CLASS = "tippy-roundarrow";
var POPPER_SELECTOR = ".".concat(POPPER_CLASS);
var TOOLTIP_SELECTOR = ".".concat(TOOLTIP_CLASS);
var CONTENT_SELECTOR = ".".concat(CONTENT_CLASS);
var BACKDROP_SELECTOR = ".".concat(BACKDROP_CLASS);
var ARROW_SELECTOR = ".".concat(ARROW_CLASS);
var ROUND_ARROW_SELECTOR = ".".concat(ROUND_ARROW_CLASS);
var isUsingTouch = false;
function onDocumentTouch() {
  if (isUsingTouch) {
    return;
  }
  isUsingTouch = true;
  if (isIOS) {
    document.body.classList.add(IOS_CLASS);
  }
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
var lastMouseMoveTime = 0;
function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    isUsingTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
    if (!isIOS) {
      document.body.classList.remove(IOS_CLASS);
    }
  }
  lastMouseMoveTime = now;
}
function onWindowBlur() {
  var _document = document, activeElement = _document.activeElement;
  if (activeElement && activeElement.blur && activeElement._tippy) {
    activeElement.blur();
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouch, PASSIVE);
  window.addEventListener("blur", onWindowBlur);
}
var keys = Object.keys(defaultProps);
function getDataAttributeOptions(reference) {
  return keys.reduce(function(acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-".concat(key)) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
}
function polyfillElementPrototypeProperties(virtualReference) {
  var polyfills = {
    isVirtual: true,
    attributes: virtualReference.attributes || {},
    contains: function contains() {
    },
    setAttribute: function setAttribute(key2, value) {
      virtualReference.attributes[key2] = value;
    },
    getAttribute: function getAttribute(key2) {
      return virtualReference.attributes[key2];
    },
    removeAttribute: function removeAttribute(key2) {
      delete virtualReference.attributes[key2];
    },
    hasAttribute: function hasAttribute(key2) {
      return key2 in virtualReference.attributes;
    },
    addEventListener: function addEventListener() {
    },
    removeEventListener: function removeEventListener() {
    },
    classList: {
      classNames: {},
      add: function add(key2) {
        virtualReference.classList.classNames[key2] = true;
      },
      remove: function remove(key2) {
        delete virtualReference.classList.classNames[key2];
      },
      contains: function contains(key2) {
        return key2 in virtualReference.classList.classNames;
      }
    }
  };
  for (var key in polyfills) {
    virtualReference[key] = polyfills[key];
  }
}
function isBareVirtualElement(value) {
  return {}.toString.call(value) === "[object Object]" && !value.addEventListener;
}
function isReferenceElement(value) {
  return !!value._tippy && !matches.call(value, POPPER_SELECTOR);
}
function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getArrayOfElements(value) {
  if (isSingular(value)) {
    return [value];
  }
  if (value instanceof NodeList) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  try {
    return arrayFrom(document.querySelectorAll(value));
  } catch (e) {
    return [];
  }
}
function getValue(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? defaultValue : v;
  }
  return value;
}
function debounce$1(fn, ms) {
  if (ms === 0) {
    return fn;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn(arg);
    }, ms);
  };
}
function getModifier(obj, key) {
  return obj && obj.modifiers && obj.modifiers[key];
}
function includes(a, b) {
  return a.indexOf(b) > -1;
}
function isRealElement(value) {
  return value instanceof Element;
}
function isSingular(value) {
  return !!(value && hasOwnProperty(value, "isVirtual")) || isRealElement(value);
}
function innerHTML() {
  return "innerHTML";
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(null, args) : value;
}
function setFlipModifierEnabled(modifiers2, value) {
  modifiers2.filter(function(m) {
    return m.name === "flip";
  })[0].enabled = value;
}
function canReceiveFocus(element) {
  return isRealElement(element) ? matches.call(element, "a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]") && !element.hasAttribute("disabled") : true;
}
function div() {
  return document.createElement("div");
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = "".concat(value, "ms");
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function evaluateProps(reference, props) {
  var out = _extends$1({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeOptions(reference));
  if (out.arrow || isUCBrowser) {
    out.animateFill = false;
  }
  return out;
}
function validateOptions(options, defaultProps2) {
  Object.keys(options).forEach(function(option) {
    if (!hasOwnProperty(defaultProps2, option)) {
      throw new Error("[tippy]: `".concat(option, "` is not a valid option"));
    }
  });
}
function setInnerHTML(element, html) {
  element[innerHTML()] = isRealElement(html) ? html[innerHTML()] : html;
}
function setContent(contentEl, props) {
  if (isRealElement(props.content)) {
    setInnerHTML(contentEl, "");
    contentEl.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    var key = props.allowHTML ? "innerHTML" : "textContent";
    contentEl[key] = props.content;
  }
}
function getChildren(popper) {
  return {
    tooltip: popper.querySelector(TOOLTIP_SELECTOR),
    backdrop: popper.querySelector(BACKDROP_SELECTOR),
    content: popper.querySelector(CONTENT_SELECTOR),
    arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(ROUND_ARROW_SELECTOR)
  };
}
function addInertia(tooltip) {
  tooltip.setAttribute("data-inertia", "");
}
function removeInertia(tooltip) {
  tooltip.removeAttribute("data-inertia");
}
function createArrowElement(arrowType) {
  var arrow2 = div();
  if (arrowType === "round") {
    arrow2.className = ROUND_ARROW_CLASS;
    setInnerHTML(arrow2, '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>');
  } else {
    arrow2.className = ARROW_CLASS;
  }
  return arrow2;
}
function createBackdropElement() {
  var backdrop = div();
  backdrop.className = BACKDROP_CLASS;
  backdrop.setAttribute("data-state", "hidden");
  return backdrop;
}
function addInteractive(popper, tooltip) {
  popper.setAttribute("tabindex", "-1");
  tooltip.setAttribute("data-interactive", "");
}
function removeInteractive(popper, tooltip) {
  popper.removeAttribute("tabindex");
  tooltip.removeAttribute("data-interactive");
}
function updateTransitionEndListener(tooltip, action, listener) {
  var eventName = isUCBrowser && document.body.style.webkitTransition !== void 0 ? "webkitTransitionEnd" : "transitionend";
  tooltip[action + "EventListener"](eventName, listener);
}
function getBasicPlacement(popper) {
  var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
  return fullPlacement ? fullPlacement.split("-")[0] : "";
}
function reflow(popper) {
  void popper.offsetHeight;
}
function updateTheme(tooltip, action, theme) {
  theme.split(" ").forEach(function(themeName) {
    tooltip.classList[action](themeName + "-theme");
  });
}
function createPopperElement(id, props) {
  var popper = div();
  popper.className = POPPER_CLASS;
  popper.id = "tippy-".concat(id);
  popper.style.zIndex = "" + props.zIndex;
  popper.style.position = "absolute";
  popper.style.top = "0";
  popper.style.left = "0";
  if (props.role) {
    popper.setAttribute("role", props.role);
  }
  var tooltip = div();
  tooltip.className = TOOLTIP_CLASS;
  tooltip.style.maxWidth = props.maxWidth + (typeof props.maxWidth === "number" ? "px" : "");
  tooltip.setAttribute("data-size", props.size);
  tooltip.setAttribute("data-animation", props.animation);
  tooltip.setAttribute("data-state", "hidden");
  updateTheme(tooltip, "add", props.theme);
  var content2 = div();
  content2.className = CONTENT_CLASS;
  content2.setAttribute("data-state", "hidden");
  if (props.interactive) {
    addInteractive(popper, tooltip);
  }
  if (props.arrow) {
    tooltip.appendChild(createArrowElement(props.arrowType));
  }
  if (props.animateFill) {
    tooltip.appendChild(createBackdropElement());
    tooltip.setAttribute("data-animatefill", "");
  }
  if (props.inertia) {
    addInertia(tooltip);
  }
  setContent(content2, props);
  tooltip.appendChild(content2);
  popper.appendChild(tooltip);
  return popper;
}
function updatePopperElement(popper, prevProps, nextProps) {
  var _getChildren = getChildren(popper), tooltip = _getChildren.tooltip, content2 = _getChildren.content, backdrop = _getChildren.backdrop, arrow2 = _getChildren.arrow;
  popper.style.zIndex = "" + nextProps.zIndex;
  tooltip.setAttribute("data-size", nextProps.size);
  tooltip.setAttribute("data-animation", nextProps.animation);
  tooltip.style.maxWidth = nextProps.maxWidth + (typeof nextProps.maxWidth === "number" ? "px" : "");
  if (nextProps.role) {
    popper.setAttribute("role", nextProps.role);
  } else {
    popper.removeAttribute("role");
  }
  if (prevProps.content !== nextProps.content) {
    setContent(content2, nextProps);
  }
  if (!prevProps.animateFill && nextProps.animateFill) {
    tooltip.appendChild(createBackdropElement());
    tooltip.setAttribute("data-animatefill", "");
  } else if (prevProps.animateFill && !nextProps.animateFill) {
    tooltip.removeChild(backdrop);
    tooltip.removeAttribute("data-animatefill");
  }
  if (!prevProps.arrow && nextProps.arrow) {
    tooltip.appendChild(createArrowElement(nextProps.arrowType));
  } else if (prevProps.arrow && !nextProps.arrow) {
    tooltip.removeChild(arrow2);
  }
  if (prevProps.arrow && nextProps.arrow && prevProps.arrowType !== nextProps.arrowType) {
    tooltip.replaceChild(createArrowElement(nextProps.arrowType), arrow2);
  }
  if (!prevProps.interactive && nextProps.interactive) {
    addInteractive(popper, tooltip);
  } else if (prevProps.interactive && !nextProps.interactive) {
    removeInteractive(popper, tooltip);
  }
  if (!prevProps.inertia && nextProps.inertia) {
    addInertia(tooltip);
  } else if (prevProps.inertia && !nextProps.inertia) {
    removeInertia(tooltip);
  }
  if (prevProps.theme !== nextProps.theme) {
    updateTheme(tooltip, "remove", prevProps.theme);
    updateTheme(tooltip, "add", nextProps.theme);
  }
}
function hideAll() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, excludedReferenceOrInstance = _ref.exclude, duration = _ref.duration;
  arrayFrom(document.querySelectorAll(POPPER_SELECTOR)).forEach(function(popper) {
    var instance = popper._tippy;
    if (instance) {
      var isExcluded = false;
      if (excludedReferenceOrInstance) {
        isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : popper === excludedReferenceOrInstance.popper;
      }
      if (!isExcluded) {
        instance.hide(duration);
      }
    }
  });
}
function isCursorOutsideInteractiveBorder(popperPlacement, popperRect, event, props) {
  if (!popperPlacement) {
    return true;
  }
  var x = event.clientX, y = event.clientY;
  var interactiveBorder = props.interactiveBorder, distance = props.distance;
  var exceedsTop = popperRect.top - y > (popperPlacement === "top" ? interactiveBorder + distance : interactiveBorder);
  var exceedsBottom = y - popperRect.bottom > (popperPlacement === "bottom" ? interactiveBorder + distance : interactiveBorder);
  var exceedsLeft = popperRect.left - x > (popperPlacement === "left" ? interactiveBorder + distance : interactiveBorder);
  var exceedsRight = x - popperRect.right > (popperPlacement === "right" ? interactiveBorder + distance : interactiveBorder);
  return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
}
function getOffsetDistanceInPx(distance) {
  return -(distance - 10) + "px";
}
var idCounter = 1;
var mouseMoveListeners = [];
function createTippy(reference, collectionProps) {
  var props = evaluateProps(reference, collectionProps);
  if (!props.multiple && reference._tippy) {
    return null;
  }
  var lastTriggerEventType;
  var lastMouseMoveEvent;
  var showTimeoutId;
  var hideTimeoutId;
  var scheduleHideAnimationFrameId;
  var isScheduledToShow = false;
  var isBeingDestroyed = false;
  var previousPlacement;
  var wasVisibleDuringPreviousUpdate = false;
  var hasMountCallbackRun = false;
  var currentMountCallback;
  var currentTransitionEndListener;
  var listeners = [];
  var currentComputedPadding;
  var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce);
  var id = idCounter++;
  var popper = createPopperElement(id, props);
  var popperChildren = getChildren(popper);
  var popperInstance = null;
  var state = {
    isEnabled: true,
    isVisible: false,
    isDestroyed: false,
    isMounted: false,
    isShown: false
  };
  var instance = {
    id,
    reference,
    popper,
    popperChildren,
    popperInstance,
    props,
    state,
    clearDelayTimeouts,
    set,
    setContent: setContent2,
    show,
    hide: hide2,
    enable,
    disable,
    destroy: destroy2
  };
  reference._tippy = instance;
  popper._tippy = instance;
  addTriggersToReference();
  if (!props.lazy) {
    createPopperInstance();
  }
  if (props.showOnInit) {
    scheduleShow();
  }
  if (props.a11y && !props.target && !canReceiveFocus(getEventListenersTarget())) {
    getEventListenersTarget().setAttribute("tabindex", "0");
  }
  popper.addEventListener("mouseenter", function(event) {
    if (instance.props.interactive && instance.state.isVisible && lastTriggerEventType === "mouseenter") {
      scheduleShow(event, true);
    }
  });
  popper.addEventListener("mouseleave", function() {
    if (instance.props.interactive && lastTriggerEventType === "mouseenter") {
      document.addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function removeFollowCursorListener() {
    document.removeEventListener("mousemove", positionVirtualReferenceNearCursor);
  }
  function cleanupInteractiveMouseListeners() {
    document.body.removeEventListener("mouseleave", scheduleHide);
    document.removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function getEventListenersTarget() {
    return instance.props.triggerTarget || reference;
  }
  function addDocumentClickListener() {
    document.addEventListener("click", onDocumentClick, true);
  }
  function removeDocumentClickListener() {
    document.removeEventListener("click", onDocumentClick, true);
  }
  function getTransitionableElements() {
    return [instance.popperChildren.tooltip, instance.popperChildren.backdrop, instance.popperChildren.content];
  }
  function getIsInLooseFollowCursorMode() {
    var followCursor = instance.props.followCursor;
    return followCursor && lastTriggerEventType !== "focus" || isUsingTouch && followCursor === "initial";
  }
  function makeSticky() {
    setTransitionDuration([popper], isIE$1 ? 0 : instance.props.updateDuration);
    var prevRefRect = reference.getBoundingClientRect();
    function updatePosition() {
      var currentRefRect = reference.getBoundingClientRect();
      if (prevRefRect.top !== currentRefRect.top || prevRefRect.right !== currentRefRect.right || prevRefRect.bottom !== currentRefRect.bottom || prevRefRect.left !== currentRefRect.left) {
        instance.popperInstance.scheduleUpdate();
      }
      prevRefRect = currentRefRect;
      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      }
    }
    updatePosition();
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var tooltip = instance.popperChildren.tooltip;
    function listener(event) {
      if (event.target === tooltip) {
        updateTransitionEndListener(tooltip, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(tooltip, "remove", currentTransitionEndListener);
    updateTransitionEndListener(tooltip, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    getEventListenersTarget().addEventListener(eventType, handler, options);
    listeners.push({
      eventType,
      handler,
      options
    });
  }
  function addTriggersToReference() {
    if (instance.props.touchHold && !instance.props.target) {
      on("touchstart", onTrigger2, PASSIVE);
      on("touchend", onMouseLeave, PASSIVE);
    }
    instance.props.trigger.trim().split(" ").forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      if (!instance.props.target) {
        on(eventType, onTrigger2);
        switch (eventType) {
          case "mouseenter":
            on("mouseleave", onMouseLeave);
            break;
          case "focus":
            on(isIE$1 ? "focusout" : "blur", onBlur);
            break;
        }
      } else {
        switch (eventType) {
          case "mouseenter":
            on("mouseover", onDelegateShow);
            on("mouseout", onDelegateHide);
            break;
          case "focus":
            on("focusin", onDelegateShow);
            on("focusout", onDelegateHide);
            break;
          case "click":
            on(eventType, onDelegateShow);
            break;
        }
      }
    });
  }
  function removeTriggersFromReference() {
    listeners.forEach(function(_ref) {
      var eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      getEventListenersTarget().removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function positionVirtualReferenceNearCursor(event) {
    var _lastMouseMoveEvent = lastMouseMoveEvent = event, x = _lastMouseMoveEvent.clientX, y = _lastMouseMoveEvent.clientY;
    if (!currentComputedPadding) {
      return;
    }
    var isCursorOverReference = closestCallback(event.target, function(el) {
      return el === reference;
    });
    var rect = reference.getBoundingClientRect();
    var followCursor = instance.props.followCursor;
    var isHorizontal = followCursor === "horizontal";
    var isVertical = followCursor === "vertical";
    var isVerticalPlacement = includes(["top", "bottom"], getBasicPlacement(popper));
    var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
    var isVariation = fullPlacement ? !!fullPlacement.split("-")[1] : false;
    var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;
    var halfSize = size / 2;
    var verticalIncrease = isVerticalPlacement ? 0 : isVariation ? size : halfSize;
    var horizontalIncrease = isVerticalPlacement ? isVariation ? size : halfSize : 0;
    if (isCursorOverReference || !instance.props.interactive) {
      instance.popperInstance.reference = _extends$1({}, instance.popperInstance.reference, {
        referenceNode: reference,
        clientWidth: 0,
        clientHeight: 0,
        getBoundingClientRect: function getBoundingClientRect2() {
          return {
            width: isVerticalPlacement ? size : 0,
            height: isVerticalPlacement ? 0 : size,
            top: (isHorizontal ? rect.top : y) - verticalIncrease,
            bottom: (isHorizontal ? rect.bottom : y) + verticalIncrease,
            left: (isVertical ? rect.left : x) - horizontalIncrease,
            right: (isVertical ? rect.right : x) + horizontalIncrease
          };
        }
      });
      instance.popperInstance.update();
    }
    if (followCursor === "initial" && instance.state.isVisible) {
      removeFollowCursorListener();
    }
  }
  function createDelegateChildTippy(event) {
    if (event) {
      var targetEl = closest(event.target, instance.props.target);
      if (targetEl && !targetEl._tippy) {
        createTippy(targetEl, _extends$1({}, instance.props, {
          content: invokeWithArgsOrReturn(collectionProps.content, [targetEl]),
          appendTo: collectionProps.appendTo,
          target: "",
          showOnInit: true
        }));
      }
    }
  }
  function onTrigger2(event) {
    if (!instance.state.isEnabled || isEventListenerStopped(event)) {
      return;
    }
    if (!instance.state.isVisible) {
      lastTriggerEventType = event.type;
      if (event instanceof MouseEvent) {
        lastMouseMoveEvent = event;
        mouseMoveListeners.forEach(function(listener) {
          return listener(event);
        });
      }
    }
    if (event.type === "click" && instance.props.hideOnClick !== false && instance.state.isVisible) {
      scheduleHide();
    } else {
      scheduleShow(event);
    }
  }
  function onMouseMove(event) {
    var isCursorOverPopper = closest(event.target, POPPER_SELECTOR) === popper;
    var isCursorOverReference = closestCallback(event.target, function(el) {
      return el === reference;
    });
    if (isCursorOverPopper || isCursorOverReference) {
      return;
    }
    if (isCursorOutsideInteractiveBorder(getBasicPlacement(popper), popper.getBoundingClientRect(), event, instance.props)) {
      cleanupInteractiveMouseListeners();
      scheduleHide();
    }
  }
  function onMouseLeave(event) {
    if (isEventListenerStopped(event)) {
      return;
    }
    if (instance.props.interactive) {
      document.body.addEventListener("mouseleave", scheduleHide);
      document.addEventListener("mousemove", debouncedOnMouseMove);
      mouseMoveListeners.push(debouncedOnMouseMove);
      return;
    }
    scheduleHide();
  }
  function onBlur(event) {
    if (event.target !== getEventListenersTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide();
  }
  function onDelegateShow(event) {
    if (closest(event.target, instance.props.target)) {
      scheduleShow(event);
    }
  }
  function onDelegateHide(event) {
    if (closest(event.target, instance.props.target)) {
      scheduleHide();
    }
  }
  function isEventListenerStopped(event) {
    var supportsTouch = "ontouchstart" in window;
    var isTouchEvent = includes(event.type, "touch");
    var touchHold = instance.props.touchHold;
    return supportsTouch && isUsingTouch && touchHold && !isTouchEvent || isUsingTouch && !touchHold && isTouchEvent;
  }
  function runMountCallback() {
    if (!hasMountCallbackRun && currentMountCallback) {
      hasMountCallbackRun = true;
      reflow(popper);
      currentMountCallback();
    }
  }
  function createPopperInstance() {
    var popperOptions = instance.props.popperOptions;
    var _instance$popperChild = instance.popperChildren, tooltip = _instance$popperChild.tooltip, arrow2 = _instance$popperChild.arrow;
    var preventOverflowModifier = getModifier(popperOptions, "preventOverflow");
    function applyMutations(data2) {
      if (instance.props.flip && !instance.props.flipOnUpdate) {
        if (data2.flipped) {
          instance.popperInstance.options.placement = data2.placement;
        }
        setFlipModifierEnabled(instance.popperInstance.modifiers, false);
      }
      tooltip.setAttribute(PLACEMENT_ATTRIBUTE, data2.placement);
      if (data2.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE] !== false) {
        tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE, "");
      } else {
        tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE);
      }
      if (previousPlacement && previousPlacement !== data2.placement && wasVisibleDuringPreviousUpdate) {
        tooltip.style.transition = "none";
        requestAnimationFrame(function() {
          tooltip.style.transition = "";
        });
      }
      previousPlacement = data2.placement;
      wasVisibleDuringPreviousUpdate = instance.state.isVisible;
      var basicPlacement = getBasicPlacement(popper);
      var styles = tooltip.style;
      styles.top = styles.bottom = styles.left = styles.right = "";
      styles[basicPlacement] = getOffsetDistanceInPx(instance.props.distance);
      var padding = preventOverflowModifier && preventOverflowModifier.padding !== void 0 ? preventOverflowModifier.padding : PADDING;
      var isPaddingNumber = typeof padding === "number";
      var computedPadding = _extends$1({
        top: isPaddingNumber ? padding : padding.top,
        bottom: isPaddingNumber ? padding : padding.bottom,
        left: isPaddingNumber ? padding : padding.left,
        right: isPaddingNumber ? padding : padding.right
      }, !isPaddingNumber && padding);
      computedPadding[basicPlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basicPlacement] || 0) + instance.props.distance;
      instance.popperInstance.modifiers.filter(function(m) {
        return m.name === "preventOverflow";
      })[0].padding = computedPadding;
      currentComputedPadding = computedPadding;
    }
    var config = _extends$1({
      eventsEnabled: false,
      placement: instance.props.placement
    }, popperOptions, {
      modifiers: _extends$1({}, popperOptions ? popperOptions.modifiers : {}, {
        preventOverflow: _extends$1({
          boundariesElement: instance.props.boundary,
          padding: PADDING
        }, preventOverflowModifier),
        arrow: _extends$1({
          element: arrow2,
          enabled: !!arrow2
        }, getModifier(popperOptions, "arrow")),
        flip: _extends$1({
          enabled: instance.props.flip,
          padding: instance.props.distance + PADDING,
          behavior: instance.props.flipBehavior
        }, getModifier(popperOptions, "flip")),
        offset: _extends$1({
          offset: instance.props.offset
        }, getModifier(popperOptions, "offset"))
      }),
      onCreate: function onCreate2(data2) {
        applyMutations(data2);
        runMountCallback();
        if (popperOptions && popperOptions.onCreate) {
          popperOptions.onCreate(data2);
        }
      },
      onUpdate: function onUpdate2(data2) {
        applyMutations(data2);
        runMountCallback();
        if (popperOptions && popperOptions.onUpdate) {
          popperOptions.onUpdate(data2);
        }
      }
    });
    instance.popperInstance = new Popper(reference, popper, config);
  }
  function mount() {
    hasMountCallbackRun = false;
    var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
    if (instance.popperInstance) {
      setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip);
      if (!isInLooseFollowCursorMode) {
        instance.popperInstance.reference = reference;
        instance.popperInstance.enableEventListeners();
      }
      instance.popperInstance.scheduleUpdate();
    } else {
      createPopperInstance();
      if (!isInLooseFollowCursorMode) {
        instance.popperInstance.enableEventListeners();
      }
    }
    var appendTo3 = instance.props.appendTo;
    var parentNode = appendTo3 === "parent" ? reference.parentNode : invokeWithArgsOrReturn(appendTo3, [reference]);
    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
      instance.props.onMount(instance);
      instance.state.isMounted = true;
    }
  }
  function scheduleShow(event, shouldAvoidCallingOnTrigger) {
    clearDelayTimeouts();
    if (instance.state.isVisible) {
      return;
    }
    if (instance.props.target) {
      return createDelegateChildTippy(event);
    }
    isScheduledToShow = true;
    if (event && !shouldAvoidCallingOnTrigger) {
      instance.props.onTrigger(instance, event);
    }
    if (instance.props.wait) {
      return instance.props.wait(instance, event);
    }
    if (getIsInLooseFollowCursorMode() && !instance.state.isMounted) {
      if (!instance.popperInstance) {
        createPopperInstance();
      }
      document.addEventListener("mousemove", positionVirtualReferenceNearCursor);
    }
    addDocumentClickListener();
    var delay = getValue(instance.props.delay, 0, defaultProps.delay);
    if (delay) {
      showTimeoutId = setTimeout(function() {
        show();
      }, delay);
    } else {
      show();
    }
  }
  function scheduleHide() {
    clearDelayTimeouts();
    if (!instance.state.isVisible) {
      removeFollowCursorListener();
      removeDocumentClickListener();
      return;
    }
    isScheduledToShow = false;
    var delay = getValue(instance.props.delay, 1, defaultProps.delay);
    if (delay) {
      hideTimeoutId = setTimeout(function() {
        if (instance.state.isVisible) {
          hide2();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrameId = requestAnimationFrame(function() {
        hide2();
      });
    }
  }
  function onDocumentClick(event) {
    if (instance.props.interactive && popper.contains(event.target)) {
      return;
    }
    if (getEventListenersTarget().contains(event.target)) {
      if (isUsingTouch) {
        return;
      }
      if (instance.state.isVisible && includes(instance.props.trigger, "click")) {
        return;
      }
    }
    if (instance.props.hideOnClick === true) {
      clearDelayTimeouts();
      hide2();
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeoutId);
    clearTimeout(hideTimeoutId);
    cancelAnimationFrame(scheduleHideAnimationFrameId);
  }
  function set(options) {
    options = options || {};
    validateOptions(options, defaultProps);
    removeTriggersFromReference();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, _extends$1({}, instance.props, {}, options, {
      ignoreAttributes: true
    }));
    nextProps.ignoreAttributes = hasOwnProperty(options, "ignoreAttributes") ? options.ignoreAttributes || false : prevProps.ignoreAttributes;
    instance.props = nextProps;
    addTriggersToReference();
    cleanupInteractiveMouseListeners();
    debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce);
    updatePopperElement(popper, prevProps, nextProps);
    instance.popperChildren = getChildren(popper);
    if (instance.popperInstance) {
      if (POPPER_INSTANCE_DEPENDENCIES.some(function(prop) {
        return hasOwnProperty(options, prop) && options[prop] !== prevProps[prop];
      })) {
        instance.popperInstance.destroy();
        createPopperInstance();
        if (instance.state.isVisible) {
          instance.popperInstance.enableEventListeners();
        }
        if (instance.props.followCursor && lastMouseMoveEvent) {
          positionVirtualReferenceNearCursor(lastMouseMoveEvent);
        }
      } else {
        instance.popperInstance.update();
      }
    }
  }
  function setContent2(content2) {
    set({
      content: content2
    });
  }
  function show() {
    var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getValue(instance.props.duration, 0, defaultProps.duration[1]);
    if (instance.state.isDestroyed || !instance.state.isEnabled || isUsingTouch && !instance.props.touch) {
      return;
    }
    if (getEventListenersTarget().hasAttribute("disabled")) {
      return;
    }
    if (instance.props.onShow(instance) === false) {
      return;
    }
    addDocumentClickListener();
    popper.style.visibility = "visible";
    instance.state.isVisible = true;
    if (instance.props.interactive) {
      getEventListenersTarget().classList.add(ACTIVE_CLASS);
    }
    var transitionableElements = getTransitionableElements();
    setTransitionDuration(transitionableElements.concat(popper), 0);
    currentMountCallback = function currentMountCallback2() {
      if (!instance.state.isVisible) {
        return;
      }
      var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
      if (isInLooseFollowCursorMode && lastMouseMoveEvent) {
        positionVirtualReferenceNearCursor(lastMouseMoveEvent);
      } else if (!isInLooseFollowCursorMode) {
        instance.popperInstance.update();
      }
      if (instance.popperChildren.backdrop) {
        instance.popperChildren.content.style.transitionDelay = Math.round(duration / 12) + "ms";
      }
      if (instance.props.sticky) {
        makeSticky();
      }
      setTransitionDuration([popper], instance.props.updateDuration);
      setTransitionDuration(transitionableElements, duration);
      setVisibilityState(transitionableElements, "visible");
      onTransitionedIn(duration, function() {
        if (instance.props.aria) {
          getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria), popper.id);
        }
        instance.props.onShown(instance);
        instance.state.isShown = true;
      });
    };
    mount();
  }
  function hide2() {
    var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getValue(instance.props.duration, 1, defaultProps.duration[1]);
    if (instance.state.isDestroyed || !instance.state.isEnabled && !isBeingDestroyed) {
      return;
    }
    if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
      return;
    }
    removeDocumentClickListener();
    popper.style.visibility = "hidden";
    instance.state.isVisible = false;
    instance.state.isShown = false;
    wasVisibleDuringPreviousUpdate = false;
    if (instance.props.interactive) {
      getEventListenersTarget().classList.remove(ACTIVE_CLASS);
    }
    var transitionableElements = getTransitionableElements();
    setTransitionDuration(transitionableElements, duration);
    setVisibilityState(transitionableElements, "hidden");
    onTransitionedOut(duration, function() {
      if (!isScheduledToShow) {
        removeFollowCursorListener();
      }
      if (instance.props.aria) {
        getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria));
      }
      instance.popperInstance.disableEventListeners();
      instance.popperInstance.options.placement = instance.props.placement;
      popper.parentNode.removeChild(popper);
      instance.props.onHidden(instance);
      instance.state.isMounted = false;
    });
  }
  function destroy2(destroyTargetInstances) {
    if (instance.state.isDestroyed) {
      return;
    }
    isBeingDestroyed = true;
    if (instance.state.isMounted) {
      hide2(0);
    }
    removeTriggersFromReference();
    delete reference._tippy;
    var target = instance.props.target;
    if (target && destroyTargetInstances && isRealElement(reference)) {
      arrayFrom(reference.querySelectorAll(target)).forEach(function(child) {
        if (child._tippy) {
          child._tippy.destroy();
        }
      });
    }
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
    }
    isBeingDestroyed = false;
    instance.state.isDestroyed = true;
  }
}
function group(instances) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$delay = _ref.delay, delay = _ref$delay === void 0 ? instances[0].props.delay : _ref$delay, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 0 : _ref$duration;
  var isAnyTippyOpen = false;
  instances.forEach(function(instance) {
    if (instance._originalProps) {
      instance.set(instance._originalProps);
    } else {
      instance._originalProps = _extends$1({}, instance.props);
    }
  });
  function setIsAnyTippyOpen(value) {
    isAnyTippyOpen = value;
    updateInstances();
  }
  function onShow3(instance) {
    instance._originalProps.onShow(instance);
    instances.forEach(function(instance2) {
      instance2.set({
        duration
      });
      if (instance2.state.isVisible) {
        instance2.hide();
      }
    });
    setIsAnyTippyOpen(true);
  }
  function onHide3(instance) {
    instance._originalProps.onHide(instance);
    setIsAnyTippyOpen(false);
  }
  function onShown3(instance) {
    instance._originalProps.onShown(instance);
    instance.set({
      duration: instance._originalProps.duration
    });
  }
  function updateInstances() {
    instances.forEach(function(instance) {
      instance.set({
        onShow: onShow3,
        onShown: onShown3,
        onHide: onHide3,
        delay: isAnyTippyOpen ? [0, Array.isArray(delay) ? delay[1] : delay] : delay,
        duration: isAnyTippyOpen ? duration : instance._originalProps.duration
      });
    });
  }
  updateInstances();
}
var globalEventListenersBound = false;
function tippy(targets, options) {
  validateOptions(options || {}, defaultProps);
  if (!globalEventListenersBound) {
    bindGlobalEventListeners();
    globalEventListenersBound = true;
  }
  var props = _extends$1({}, defaultProps, {}, options);
  if (isBareVirtualElement(targets)) {
    polyfillElementPrototypeProperties(targets);
  }
  var instances = getArrayOfElements(targets).reduce(function(acc, reference) {
    var instance = reference && createTippy(reference, props);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isSingular(targets) ? instances[0] : instances;
}
tippy.version = version;
tippy.defaults = defaultProps;
tippy.setDefaults = function(partialDefaults) {
  Object.keys(partialDefaults).forEach(function(key) {
    defaultProps[key] = partialDefaults[key];
  });
};
tippy.hideAll = hideAll;
tippy.group = group;
function autoInit() {
  arrayFrom(document.querySelectorAll("[data-tippy]")).forEach(function(el) {
    var content2 = el.getAttribute("data-tippy");
    if (content2) {
      tippy(el, {
        content: content2
      });
    }
  });
}
if (isBrowser$1) {
  setTimeout(autoInit);
}
function injectCSS(css2) {
  if (isBrowser$1) {
    var style = document.createElement("style");
    style.type = "text/css";
    style.textContent = css2;
    style.setAttribute("data-tippy-stylesheet", "");
    var head = document.head;
    var firstStyleOrLinkTag = head.querySelector("style,link");
    if (firstStyleOrLinkTag) {
      head.insertBefore(style, firstStyleOrLinkTag);
    } else {
      head.appendChild(style);
    }
  }
}
injectCSS(css);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var humps = createCommonjsModule(function(module) {
  (function(global2) {
    var _processKeys = function(convert, obj, options) {
      if (!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {
        return obj;
      }
      var output, i = 0, l = 0;
      if (_isArray(obj)) {
        output = [];
        for (l = obj.length; i < l; i++) {
          output.push(_processKeys(convert, obj[i], options));
        }
      } else {
        output = {};
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            output[convert(key, options)] = _processKeys(convert, obj[key], options);
          }
        }
      }
      return output;
    };
    var separateWords = function(string, options) {
      options = options || {};
      var separator = options.separator || "_";
      var split = options.split || /(?=[A-Z])/;
      return string.split(split).join(separator);
    };
    var camelize = function(string) {
      if (_isNumerical(string)) {
        return string;
      }
      string = string.replace(/[\-_\s]+(.)?/g, function(match, chr) {
        return chr ? chr.toUpperCase() : "";
      });
      return string.substr(0, 1).toLowerCase() + string.substr(1);
    };
    var pascalize = function(string) {
      var camelized = camelize(string);
      return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);
    };
    var decamelize = function(string, options) {
      return separateWords(string, options).toLowerCase();
    };
    var toString = Object.prototype.toString;
    var _isFunction = function(obj) {
      return typeof obj === "function";
    };
    var _isObject = function(obj) {
      return obj === Object(obj);
    };
    var _isArray = function(obj) {
      return toString.call(obj) == "[object Array]";
    };
    var _isDate = function(obj) {
      return toString.call(obj) == "[object Date]";
    };
    var _isRegExp = function(obj) {
      return toString.call(obj) == "[object RegExp]";
    };
    var _isBoolean = function(obj) {
      return toString.call(obj) == "[object Boolean]";
    };
    var _isNumerical = function(obj) {
      obj = obj - 0;
      return obj === obj;
    };
    var _processor = function(convert, options) {
      var callback = options && "process" in options ? options.process : options;
      if (typeof callback !== "function") {
        return convert;
      }
      return function(string, options2) {
        return callback(string, convert, options2);
      };
    };
    var humps2 = {
      camelize,
      decamelize,
      pascalize,
      depascalize: decamelize,
      camelizeKeys: function(object, options) {
        return _processKeys(_processor(camelize, options), object);
      },
      decamelizeKeys: function(object, options) {
        return _processKeys(_processor(decamelize, options), object, options);
      },
      pascalizeKeys: function(object, options) {
        return _processKeys(_processor(pascalize, options), object);
      },
      depascalizeKeys: function() {
        return this.decamelizeKeys.apply(this, arguments);
      }
    };
    if (module.exports) {
      module.exports = humps2;
    } else {
      global2.humps = humps2;
    }
  })(commonjsGlobal);
});
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var booleanProps = {
  a11y: true,
  allowHTML: true,
  animateFill: true,
  arrow: false,
  flip: true,
  flipOnUpdate: false,
  followCursor: false,
  hideOnClick: true,
  ignoreAttributes: false,
  inertia: false,
  interactive: false,
  lazy: true,
  multiple: false,
  showOnInit: false,
  sticky: false,
  touch: true,
  touchHold: false
};
var defaultProps$1 = _objectSpread2({
  animation: "shift-away",
  appendTo: function appendTo2() {
    return document.body;
  },
  aria: "describedby",
  arrowType: "sharp",
  boundary: "scrollParent",
  content: "",
  delay: 0,
  distance: 10,
  duration: [325, 275],
  flipBehavior: "flip",
  interactiveBorder: 2,
  interactiveDebounce: 0,
  maxWidth: 350,
  offset: 0,
  onHidden: function onHidden2() {
  },
  onHide: function onHide2() {
  },
  onMount: function onMount2() {
  },
  onShow: function onShow2() {
  },
  onShown: function onShown2() {
  },
  placement: "top",
  popperOptions: {},
  role: "tooltip",
  size: "regular",
  target: "",
  theme: "dark",
  trigger: "mouseenter focus",
  updateDuration: 0,
  wait: null,
  zIndex: 9999
}, booleanProps);
var script = {
  props: {
    to: void 0,
    toSelector: void 0,
    toElement: void 0,
    content: void 0,
    enabled: void 0,
    visible: void 0,
    triggerTarget: void 0,
    tag: {
      type: String,
      default: "div"
    },
    triggerTag: String,
    contentTag: String
  },
  data: function data() {
    return {
      tip: null,
      options: {}
    };
  },
  mounted: function mounted() {
    this.init();
  },
  watch: {
    content: function content() {
      if (this.tip) {
        this.tip.set(this.getOptions());
      }
    },
    enabled: function enabled(val) {
      if (!this.tip)
        return;
      if (val) {
        this.tip.enable();
      } else {
        this.tip.hide();
        this.tip.disable();
      }
    },
    visible: function visible(val) {
      if (!this.tip)
        return;
      if (val) {
        this.tip.show();
      } else {
        this.tip.hide();
      }
    }
  },
  updated: function updated() {
    if (this.tip && !this.content) {
      this.tip.set(this.getOptions());
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (!this.tip)
      return;
    this.tip.destroy();
  },
  computed: {
    isManualTrigger: function isManualTrigger() {
      return this.options.trigger === "manual";
    }
  },
  methods: {
    init: function init() {
      if (this.tip) {
        try {
          this.tip.destroy();
        } catch (error) {
        }
        this.tip = null;
      }
      var elm = this.toElement;
      if (elm == null) {
        if (this.to) {
          elm = document.querySelector("[name='".concat(this.to, "']"));
        } else if (this.toSelector) {
          elm = document.querySelector(this.toSelector);
        } else if (this.$refs.trigger && this.$refs.trigger.childElementCount > 0) {
          elm = this.$refs.trigger;
        } else {
          elm = this.$el.parentElement;
        }
      }
      if (!elm) {
        return;
      }
      var tip = tippy(elm, this.getOptions());
      if (!tip) {
        return;
      }
      if (Array.isArray(tip)) {
        if (tip.length > 0) {
          this.tip = tip[0];
        } else {
          return;
        }
      }
      this.tip = tip;
      this.$emit("onCreate", this.tip);
      this.$emit("init", this.tip);
      if (this.enabled === false) {
        this.tip.disable();
      }
      if (this.isManualTrigger && this.visible === true) {
        this.tip.show();
      }
    },
    tippy: function tippy2() {
      return this.tip;
    },
    filterOptions: function filterOptions() {
      var getValue2 = function getValue3(key2, value) {
        if (booleanProps.hasOwnProperty(key2)) {
          if (value === "")
            return true;
          if (value === "false")
            return false;
          if (value === "true")
            return true;
        }
        return value;
      };
      for (var _i = 0, _Object$keys = Object.keys(this.options); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        if (!defaultProps$1.hasOwnProperty(key)) {
          delete this.options[key];
        } else {
          this.options[key] = getValue2(key, this.options[key]);
        }
      }
      return this.options;
    },
    getOptions: function getOptions() {
      var _this = this;
      this.options.content = this.content ? this.content : this.$refs.content;
      Object.assign(this.options, humps.camelizeKeys(this.$attrs));
      this.filterOptions();
      if (!this.options.onShow && this.$listeners && this.$listeners["show"]) {
        this.options.onShow = function() {
          var _this$$listeners$show;
          return (_this$$listeners$show = _this.$listeners["show"]).fns.apply(_this$$listeners$show, arguments);
        };
      }
      if (!this.options.onShow && this.$listeners && this.$listeners["shown"]) {
        this.options.onShown = function() {
          var _this$$listeners$show2;
          return (_this$$listeners$show2 = _this.$listeners["shown"]).fns.apply(_this$$listeners$show2, arguments);
        };
      }
      if (!this.options.onHidden && this.$listeners && this.$listeners["hidden"]) {
        this.options.onHidden = function() {
          var _this$$listeners$hidd;
          return (_this$$listeners$hidd = _this.$listeners["hidden"]).fns.apply(_this$$listeners$hidd, arguments);
        };
      }
      if (!this.options.onHide && this.$listeners && this.$listeners["hide"]) {
        this.options.onHide = function() {
          var _this$$listeners$hide;
          return (_this$$listeners$hide = _this.$listeners["hide"]).fns.apply(_this$$listeners$hide, arguments);
        };
      }
      if (!this.options.onMount && this.$listeners && this.$listeners["mount"]) {
        this.options.onMount = function() {
          var _this$$listeners$moun;
          return (_this$$listeners$moun = _this.$listeners["mount"]).fns.apply(_this$$listeners$moun, arguments);
        };
      }
      this.options.triggerTarget = this.triggerTarget;
      return this.options;
    }
  }
};
function normalizeComponent(template, style, script2, scopeId, isFunctionalTemplate, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== "boolean") {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  }
  var options = typeof script2 === "function" ? script2.options : script2;
  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true;
    if (isFunctionalTemplate) {
      options.functional = true;
    }
  }
  if (scopeId) {
    options._scopeId = scopeId;
  }
  var hook;
  if (moduleIdentifier) {
    hook = function hook2(context) {
      context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
      if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
        context = __VUE_SSR_CONTEXT__;
      }
      if (style) {
        style.call(this, createInjectorSSR(context));
      }
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    };
    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function() {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function(context) {
      style.call(this, createInjector(context));
    };
  }
  if (hook) {
    if (options.functional) {
      var originalRender = options.render;
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }
  return script2;
}
var normalizeComponent_1 = normalizeComponent;
var __vue_script__ = script;
var __vue_render__ = function __vue_render__2() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.tag, {
    tag: "component",
    attrs: {
      "data-tippy-component": ""
    }
  }, [_c(_vm.triggerTag || _vm.tag, {
    ref: "trigger",
    tag: "component",
    attrs: {
      "data-tippy-component-trigger": ""
    }
  }, [_vm._t("trigger")], 2), _vm._v(" "), _c(_vm.contentTag || _vm.tag, {
    ref: "content",
    tag: "component"
  }, [_vm._t("default")], 2)], 1);
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;
var __vue_inject_styles__ = void 0;
var __vue_scope_id__ = void 0;
var __vue_module_identifier__ = void 0;
var __vue_is_functional_template__ = false;
var TippyComponent = normalizeComponent_1({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, void 0, void 0);
var tippyDirective = "tippy";
var plugin = {
  install: function install(Vue) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    tippyDirective = options.directive || "tippy";
    tippy.setDefaults(options || {});
    function createTippy2(el, binding, vnode) {
      var handlers = vnode.data && vnode.data.on || vnode.componentOptions && vnode.componentOptions.listeners;
      el.setAttribute("data-tippy-directive", "");
      var opts = deriveOpts(binding);
      var modifiers2 = Object.keys(binding.modifiers || {});
      var placement = modifiers2.find(function(modifier) {
        return modifier !== "arrow";
      });
      var withArrow = modifiers2.findIndex(function(modifier) {
        return modifier === "arrow";
      }) !== -1;
      opts = Object.assign({}, options, opts);
      if (placement) {
        opts.placement = opts.placement || placement;
      }
      if (withArrow) {
        opts.arrow = opts.arrow !== void 0 ? opts.arrow : true;
      }
      if (handlers && handlers["show"]) {
        opts.onShow = function() {
          var _handlers$show;
          return (_handlers$show = handlers["show"]).fns.apply(_handlers$show, arguments);
        };
      }
      if (handlers && handlers["shown"]) {
        opts.onShown = function() {
          var _handlers$shown;
          (_handlers$shown = handlers["shown"]).fns.apply(_handlers$shown, arguments);
        };
      }
      if (handlers && handlers["hidden"]) {
        opts.onHidden = function() {
          var _handlers$hidden;
          (_handlers$hidden = handlers["hidden"]).fns.apply(_handlers$hidden, arguments);
        };
      }
      if (handlers && handlers["hide"]) {
        opts.onHide = function() {
          var _handlers$hide;
          return (_handlers$hide = handlers["hide"]).fns.apply(_handlers$hide, arguments);
        };
      }
      if (handlers && handlers["mount"]) {
        opts.onMount = function() {
          var _handlers$mount;
          (_handlers$mount = handlers["mount"]).fns.apply(_handlers$mount, arguments);
        };
      }
      if (el.getAttribute("title") && !opts.content) {
        opts.content = el.getAttribute("title");
        el.removeAttribute("title");
      }
      if (el.getAttribute("content") && !opts.content) {
        opts.content = el.getAttribute("content");
      }
      tippy(el, opts);
      if (opts.showOnLoad) {
        el._tippy.show();
      }
      Vue.nextTick(function() {
        if (handlers && handlers["init"]) {
          handlers["init"].fns(el._tippy, el);
        }
      });
    }
    Vue.directive(tippyDirective, {
      inserted: function inserted(el, binding, vnode) {
        Vue.nextTick(function() {
          createTippy2(el, binding, vnode);
        });
      },
      unbind: function unbind(el) {
        el._tippy && el._tippy.destroy();
      },
      componentUpdated: function componentUpdated(el, binding, vnode) {
        if (el._tippy) {
          var opts = deriveOpts(binding);
          if (el.getAttribute("title") && !opts.content) {
            opts.content = el.getAttribute("title");
            el.removeAttribute("title");
          }
          if (el.getAttribute("content") && !opts.content) {
            opts.content = el.getAttribute("content");
          }
          el._tippy.set(opts);
        }
      }
    });
    function deriveOpts(binding) {
      return typeof binding.value === "string" ? {
        content: binding.value
      } : binding.value || {};
    }
  }
};
if (typeof window !== "undefined" && window.Vue) {
  window.Vue.use(plugin);
  window.Vue.component("tippy", TippyComponent);
}
var vue_tippy_esm_default = plugin;

// dep:vue-tippy_dist_vue-tippy_esm
var vue_tippy_dist_vue_tippy_esm_default = vue_tippy_esm_default;
export {
  TippyComponent,
  vue_tippy_dist_vue_tippy_esm_default as default,
  tippy
};
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
//# sourceMappingURL=vue-tippy_dist_vue-tippy_esm.js.map
