import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/querystring/decode.js
var require_decode = __commonJS({
  "node_modules/querystring/decode.js"(exports, module) {
    "use strict";
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    module.exports = function(qs, sep, eq, options) {
      sep = sep || "&";
      eq = eq || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = "";
        }
        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);
        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (Array.isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }
      return obj;
    };
  }
});

// node_modules/querystring/encode.js
var require_encode = __commonJS({
  "node_modules/querystring/encode.js"(exports, module) {
    "use strict";
    var stringifyPrimitive = function(v) {
      switch (typeof v) {
        case "string":
          return v;
        case "boolean":
          return v ? "true" : "false";
        case "number":
          return isFinite(v) ? v : "";
        default:
          return "";
      }
    };
    module.exports = function(obj, sep, eq, name) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return Object.keys(obj).map(function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (Array.isArray(obj[k])) {
            return obj[k].map(function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).filter(Boolean).join(sep);
      }
      if (!name)
        return "";
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
  }
});

// node_modules/querystring/index.js
var require_querystring = __commonJS({
  "node_modules/querystring/index.js"(exports) {
    "use strict";
    exports.decode = exports.parse = require_decode();
    exports.encode = exports.stringify = require_encode();
  }
});

// browser-external:crypto
var crypto_exports = {};
__export(crypto_exports, {
  default: () => crypto_default
});
var crypto_default;
var init_crypto = __esm({
  "browser-external:crypto"() {
    crypto_default = new Proxy({}, {
      get() {
        throw new Error('Module "crypto" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/lastfm-typed/dist/caster.js
var require_caster = __commonJS({
  "node_modules/lastfm-typed/dist/caster.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertString = exports.addConditionals = exports.convertExtendedMeta = exports.convertBasicMetaTag = exports.joinArray = exports.convertGetRecentTracks = exports.setDate = exports.convertEntryArray = exports.convertEntry = exports.convertImageArray = exports.convertImage = exports.convertSearchWithQuery = exports.convertSearch = exports.convertMeta = exports.toArray = exports.toBool = exports.boolToInt = exports.toInt = void 0;
    function toInt(num) {
      if (typeof num === "number") {
        return num;
      }
      const res = parseInt(num, 10);
      return isNaN(res) ? null : res;
    }
    exports.toInt = toInt;
    var boolToInt = (bool) => Number(bool);
    exports.boolToInt = boolToInt;
    var toBool = (bool) => bool !== 0 && bool && bool !== "0";
    exports.toBool = toBool;
    function toArray(arr) {
      if (arr instanceof Array) {
        return arr;
      }
      if (!arr) {
        return [];
      }
      return [arr];
    }
    exports.toArray = toArray;
    function convertMeta(meta) {
      for (let key of ["page", "perPage", "total", "totalPages", "from", "to", "index", "accepted", "ignored"]) {
        if (meta.hasOwnProperty(key)) {
          meta[key] = toInt(meta[key]);
        }
      }
      for (let key of ["artistcorrected", "trackcorrected"]) {
        if (meta.hasOwnProperty(key)) {
          meta[key] = (0, exports.toBool)(meta[key]);
        }
      }
      return meta;
    }
    exports.convertMeta = convertMeta;
    function convertSearch(res) {
      var _a;
      if (!res.meta) {
        res.meta = {};
      }
      delete res["opensearch:Query"]["#text"];
      res.meta.itemsPerPage = toInt(res["opensearch:itemsPerPage"]);
      delete res["opensearch:itemsPerPage"];
      res.meta.startIndex = toInt(res["opensearch:startIndex"]);
      delete res["opensearch:startIndex"];
      res.meta.totalResults = toInt(res["opensearch:totalResults"]);
      delete res["opensearch:totalResults"];
      res.meta.query = { ...res.meta.query, ...res["opensearch:Query"] };
      delete res["opensearch:Query"];
      if ((_a = res.meta.query) === null || _a === void 0 ? void 0 : _a.startPage) {
        res.meta.query.startPage = toInt(res.meta.query.startPage);
      }
      return res;
    }
    exports.convertSearch = convertSearch;
    function convertSearchWithQuery(res) {
      res.meta;
      res.meta = res["@attr"];
      delete res["@attr"];
      res.meta.query = { for: res.meta.for };
      delete res.meta.for;
      return convertSearch(res);
    }
    exports.convertSearchWithQuery = convertSearchWithQuery;
    function convertImage(img) {
      img.url = img["#text"];
      delete img["#text"];
      return img;
    }
    exports.convertImage = convertImage;
    var convertImageArray = (img) => toArray(img).map(convertImage);
    exports.convertImageArray = convertImageArray;
    function entryIntConverter(e) {
      var _a;
      for (let key of ["playcount", "listeners", "tagcount", "userplaycount", "rank", "duration", "taggings", "reach", "bootstrap", "age", "count", "match"]) {
        if (e.hasOwnProperty(key)) {
          e[key] = toInt(e[key]);
          continue;
        }
        if ((_a = e["@attr"]) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(key)) {
          e[key] = toInt(e["@attr"][key]);
          delete e["@attr"];
        }
      }
      return e;
    }
    function entryStreamableConverter(e) {
      var _a, _b;
      if (e.hasOwnProperty("streamable")) {
        if (e.streamable.hasOwnProperty("fulltrack")) {
          e.streamable.isStreamable = (0, exports.toBool)(e.streamable["#text"]);
          delete e.streamable["#text"];
          e.streamable.fulltrack = (0, exports.toBool)(e.streamable.fulltrack);
        } else {
          e.streamable = (0, exports.toBool)((_b = (_a = e.streamable) === null || _a === void 0 ? void 0 : _a["#text"]) !== null && _b !== void 0 ? _b : e.streamable);
        }
      }
      return e;
    }
    function convertEntry(e) {
      e = entryIntConverter(e);
      for (let key of ["ontour", "userloved", "subscriber", "loved"]) {
        if (e.hasOwnProperty(key)) {
          e[key] = (0, exports.toBool)(e[key]);
        }
      }
      e = entryStreamableConverter(e);
      if (e.hasOwnProperty("image")) {
        e.image = (0, exports.convertImageArray)(e.image);
      }
      return e;
    }
    exports.convertEntry = convertEntry;
    var convertEntryArray = (e) => toArray(e).map(convertEntry);
    exports.convertEntryArray = convertEntryArray;
    function setName(e) {
      var _a;
      if (!e.artist.hasOwnProperty("name")) {
        e.artist.name = e.artist["#text"];
        delete e.artist["#text"];
      }
      if (e.hasOwnProperty("album")) {
        (_a = e.album).name || (_a.name = e.album["#text"]);
        delete e.album["#text"];
      }
      return e;
    }
    function setDate(e, prop) {
      var _a;
      if (e.hasOwnProperty(prop)) {
        e[prop].datetime = e[prop]["#text"];
        delete e[prop]["#text"];
        e[prop].uts = toInt((_a = e[prop].uts) !== null && _a !== void 0 ? _a : e[prop].unixtime);
        delete e[prop].unixtime;
      }
      return e;
    }
    exports.setDate = setDate;
    function convertGetRecentTracksEntry(e) {
      var _a;
      e = setName(e);
      e = setDate(e, "date");
      if ((_a = e === null || e === void 0 ? void 0 : e["@attr"]) === null || _a === void 0 ? void 0 : _a.hasOwnProperty("nowplaying")) {
        e.nowplaying = (0, exports.toBool)(e["@attr"].nowplaying);
        delete e["@attr"];
      } else {
        e.nowplaying = false;
      }
      return convertEntry(e);
    }
    var convertGetRecentTracks = (e) => toArray(e).map(convertGetRecentTracksEntry);
    exports.convertGetRecentTracks = convertGetRecentTracks;
    var joinArray = (e) => Array.isArray(e) ? e.join(",") : e;
    exports.joinArray = joinArray;
    function convertBasicMetaTag(res) {
      res.meta = res["@attr"];
      delete res["@attr"];
      res.tags = toArray(res.tag);
      delete res.tag;
      return res;
    }
    exports.convertBasicMetaTag = convertBasicMetaTag;
    function convertExtendedMeta(res, type) {
      res.meta = convertMeta(res["@attr"]);
      delete res["@attr"];
      res[`${type}s`] = (0, exports.convertEntryArray)(res[type]);
      delete res[type];
      return res;
    }
    exports.convertExtendedMeta = convertExtendedMeta;
    function addConditionals(req, props) {
      for (let [key, value] of Object.entries(props)) {
        if (value !== void 0) {
          req[key] = value;
        }
      }
      return req;
    }
    exports.addConditionals = addConditionals;
    function convertString(str, name, props) {
      if (typeof str !== "string") {
        return str;
      }
      let obj = {};
      obj[name] = str;
      return addConditionals(obj, props);
    }
    exports.convertString = convertString;
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global.DOMException;
      }
      F.prototype = global;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/lastfm-typed/dist/request.js
var require_request = __commonJS({
  "node_modules/lastfm-typed/dist/request.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LFMRequest = void 0;
    var querystring_1 = require_querystring();
    var crypto = __importStar((init_crypto(), __toCommonJS(crypto_exports)));
    var caster_1 = require_caster();
    var cross_fetch_1 = __importDefault(require_browser_ponyfill());
    var LFMRequest = class {
      constructor(info, userAgent, secureConnection, params) {
        var _a, _b;
        this.key = info.key;
        this.params = Object.fromEntries(Object.entries(params).filter((e) => e[1] !== void 0 && e[1] !== null));
        this.secret = info.secret;
        this.userAgent = userAgent;
        this.connectionType = secureConnection ? "https" : "http";
        this.context = info.context;
        this.startTime = Date.now();
        if (this.params.hasOwnProperty("autocorrect")) {
          this.params.autocorrect = (0, caster_1.boolToInt)((_a = this.params.autocorrect) !== null && _a !== void 0 ? _a : true);
        }
        if (this.params.hasOwnProperty("recenttracks")) {
          this.params.recenttracks = (0, caster_1.boolToInt)((_b = this.params.recenttracks) !== null && _b !== void 0 ? _b : true);
        }
        if (this.params.hasOwnProperty("usernameOrSessionKey")) {
          this.params.user = this.params.usernameOrSessionKey;
          delete this.params.usernameOrSessionKey;
        }
      }
      async execute() {
        const isPostRequest = this.isPostRequest();
        this.context.logger.emitRequest(this.params, isPostRequest ? "POST" : "GET");
        if (isPostRequest) {
          if (this.secret === "") {
            throw new SyntaxError("Please enter an api secret key to use post requests with session key.");
          }
          this.startTime = Date.now();
          this.response = await this.post();
        } else {
          this.startTime = Date.now();
          this.response = await this.get();
        }
        return {
          res: await this.checkStatus(),
          time: Date.now() - this.startTime
        };
      }
      async checkStatus() {
        if (!this.response.ok) {
          const response = await this.response.json();
          if (typeof response === "object" && response !== null && response.hasOwnProperty("error") && response.hasOwnProperty("message")) {
            throw {
              code: response.error,
              message: response.message
            };
          } else {
            throw {
              message: this.response.statusText,
              response
            };
          }
        }
        try {
          this.response = await this.response.json();
        } catch (err) {
          throw new Error("Returned invalid json! Most likely a Last.FM issue.");
        }
        if (this.response.hasOwnProperty("error")) {
          let error = {
            message: this.response.message,
            code: this.response.error
          };
          throw error;
        }
        return this.response;
      }
      async post() {
        if (this.params.hasOwnProperty("user")) {
          this.params.sk = this.params.user;
          delete this.params.user;
        }
        if (this.params.hasOwnProperty("username")) {
          this.params.sk = this.params.username;
          delete this.params.username;
        }
        const api_sig = this.getSignature();
        const requestParam = {
          ...this.params,
          api_key: this.key,
          format: "json",
          api_sig
        };
        const paramString = (0, querystring_1.stringify)(requestParam);
        return await (0, cross_fetch_1.default)(`${this.connectionType}://ws.audioscrobbler.com/2.0/`, {
          method: "POST",
          headers: {
            "Content-Length": Buffer.byteLength(paramString).toString(),
            "Content-Type": "application/x-www-form-urlencoded",
            "User-Agent": this.userAgent
          },
          body: paramString
        });
      }
      async get() {
        const params = {
          api_key: this.key,
          format: "json",
          ...this.params
        };
        return await (0, cross_fetch_1.default)(`${this.connectionType}://ws.audioscrobbler.com/2.0?${(0, querystring_1.stringify)(params)}`, {
          method: "GET",
          headers: {
            "User-Agent": this.userAgent
          }
        });
      }
      getSignature() {
        const paramObj = {
          ...this.params,
          api_key: this.key
        };
        const args = Object.keys(paramObj).sort().map((e) => [e, paramObj[e]]);
        let sig = args.reduce((acc, cur) => `${acc}${cur[0]}${cur[1]}`, "");
        sig = crypto.createHash("md5").update(sig + this.secret).digest("hex");
        return sig;
      }
      isPostRequest() {
        var _a, _b;
        return ((_a = this.params.user) === null || _a === void 0 ? void 0 : _a.length) === 32 || ((_b = this.params.username) === null || _b === void 0 ? void 0 : _b.length) === 32 || this.params.hasOwnProperty("sk") || this.params.hasOwnProperty("token") || this.params.hasOwnProperty("password");
      }
    };
    exports.LFMRequest = LFMRequest;
  }
});

// node_modules/lastfm-typed/dist/base.js
var require_base = __commonJS({
  "node_modules/lastfm-typed/dist/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var request_1 = require_request();
    var LFMBase = class {
      constructor(apiKey, lastfm, apiSecret = "", userAgent = "lastfm-typed-npm", secureConnection = false) {
        this.key = apiKey;
        this.secret = apiSecret;
        this.userAgent = userAgent;
        this.secureConnection = secureConnection;
        this.info = lastfm.info;
      }
      checkLimit(limit, maxLimit) {
        if (typeof limit !== "undefined" && (limit > maxLimit || limit < 1)) {
          throw { message: `Limit out of bounds (1-${maxLimit}), ${limit} passed`, code: 6 };
        }
      }
      checkScrobbleCount(scrobbleCount, maxScrobbleCount) {
        if (typeof scrobbleCount === "undefined" || (scrobbleCount > maxScrobbleCount || scrobbleCount < 1)) {
          throw { message: `Scrobble count out of bounds (1-${maxScrobbleCount}), ${scrobbleCount} passed`, code: 6 };
        }
      }
      convertNumRes(params) {
        let newParams = {
          num_res: 50,
          offset: 0
        };
        newParams.num_res = (params === null || params === void 0 ? void 0 : params.limit) || 50;
        newParams.offset = (((params === null || params === void 0 ? void 0 : params.page) || 1) - 1) * newParams.num_res;
        return newParams;
      }
      convertGetTags(res) {
        if ((res === null || res === void 0 ? void 0 : res["#text"]) === " ") {
          res.tag = [];
          delete res["#text"];
        }
        return res;
      }
      async sendRequest(params) {
        const res = await new request_1.LFMRequest(this.info, this.userAgent, this.secureConnection, params).execute();
        this.info.context.logger.emitRequestComplete(params, res.time, res.res);
        return res.res;
      }
    };
    exports.default = LFMBase;
  }
});

// node_modules/lastfm-typed/dist/classes/tag.js
var require_tag = __commonJS({
  "node_modules/lastfm-typed/dist/classes/tag.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = __importDefault(require_base());
    var caster_1 = require_caster();
    var TagClass = class extends base_1.default {
      async getInfo(firstInput, params) {
        firstInput = (0, caster_1.convertString)(firstInput, "tag", params !== null && params !== void 0 ? params : {});
        return (await this.sendRequest({ method: "tag.getInfo", ...firstInput, ...params })).tag;
      }
      async getTopAlbums(firstInput, params) {
        firstInput = (0, caster_1.convertString)(firstInput, "tag", params !== null && params !== void 0 ? params : {});
        let res = (await this.getTop("tag.getTopAlbums", firstInput, params)).albums;
        return (0, caster_1.convertExtendedMeta)(res, "album");
      }
      async getTopArtists(firstInput, params) {
        firstInput = (0, caster_1.convertString)(firstInput, "tag", params !== null && params !== void 0 ? params : {});
        let res = (await this.getTop("tag.getTopArtists", firstInput, params)).topartists;
        return (0, caster_1.convertExtendedMeta)(res, "artist");
      }
      async getTopTags(params) {
        const newParams = this.convertNumRes(params);
        let res = (await this.getTop("tag.getTopTags", {}, newParams)).toptags;
        const total = (0, caster_1.toInt)(res["@attr"].total);
        if (total === null) {
          throw "Total is not a number";
        }
        let attr = {
          total,
          page: newParams.offset / newParams.num_res + 1,
          perPage: newParams.num_res,
          totalPages: Math.ceil(total) / newParams.num_res
        };
        res.meta = attr;
        delete res["@attr"];
        res.tags = (0, caster_1.convertEntryArray)(res.tag);
        delete res.tag;
        return res;
      }
      async getTopTracks(firstInput, params) {
        firstInput = (0, caster_1.convertString)(firstInput, "tag", params !== null && params !== void 0 ? params : {});
        let res = (await this.getTop("tag.getTopTracks", firstInput, params)).tracks;
        return (0, caster_1.convertExtendedMeta)(res, "track");
      }
      async getTop(method, firstInput, params) {
        var _a, _b;
        this.checkLimit(((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput === null || firstInput === void 0 ? void 0 : firstInput.limit) || ((_b = params === null || params === void 0 ? void 0 : params.num_res) !== null && _b !== void 0 ? _b : firstInput === null || firstInput === void 0 ? void 0 : firstInput.num_res), 1e3);
        return await this.sendRequest({ method, ...firstInput, ...params });
      }
    };
    exports.default = TagClass;
  }
});

// node_modules/lastfm-typed/dist/classes/chart.js
var require_chart = __commonJS({
  "node_modules/lastfm-typed/dist/classes/chart.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = __importDefault(require_base());
    var caster_1 = require_caster();
    var ChartClass = class extends base_1.default {
      async getTopArtists(params) {
        let res = (await this.getTop("chart.getTopArtists", params)).artists;
        return (0, caster_1.convertExtendedMeta)(res, "artist");
      }
      async getTopTags(params) {
        let res = (await this.getTop("chart.getTopTags", params)).tags;
        return (0, caster_1.convertExtendedMeta)(res, "tag");
      }
      async getTopTracks(params) {
        let res = (await this.getTop("chart.getTopTracks", params)).tracks;
        return (0, caster_1.convertExtendedMeta)(res, "track");
      }
      async getTop(method, params) {
        this.checkLimit(params === null || params === void 0 ? void 0 : params.limit, 1e3);
        return await this.sendRequest({ method, ...params });
      }
    };
    exports.default = ChartClass;
  }
});

// node_modules/lastfm-typed/dist/classes/auth.js
var require_auth = __commonJS({
  "node_modules/lastfm-typed/dist/classes/auth.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = __importDefault(require_base());
    var caster_1 = require_caster();
    var AuthClass = class extends base_1.default {
      async getToken(firstInput) {
        const token = await this.sendRequest({ method: "auth.getToken" });
        if (typeof token.token === "undefined") {
          throw Error("Something went wrong while getting the token. Probably because of Last.FM");
        }
        return token.token;
      }
      async getSession(firstInput) {
        firstInput = (0, caster_1.convertString)(firstInput, "token", {});
        const res = (await this.sendRequest({ method: "auth.getSession", ...firstInput })).session;
        res.subscriber = (0, caster_1.toBool)(res.subscriber);
        return res;
      }
      async getMobileSession(firstInput, password, token) {
        firstInput = (0, caster_1.convertString)(firstInput, "username", { password, token });
        return (await this.sendRequest({ method: "auth.getMobileSession", ...firstInput })).session;
      }
    };
    exports.default = AuthClass;
  }
});

// node_modules/lastfm-typed/dist/classes/album.js
var require_album = __commonJS({
  "node_modules/lastfm-typed/dist/classes/album.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = __importDefault(require_base());
    var caster_1 = require_caster();
    var AlbumClass = class extends base_1.default {
      async addTags(firstInput, album, tags, sk) {
        firstInput = (0, caster_1.convertString)(firstInput, "artist", { album, tags, sk });
        firstInput.tags = (0, caster_1.joinArray)(firstInput.tags);
        return await this.sendRequest({ method: "album.addTags", ...firstInput });
      }
      async getInfo(firstInput, params) {
        var _a, _b;
        let res = (await this.sendRequest({ method: "album.getInfo", ...firstInput, ...params })).album;
        res = (0, caster_1.convertEntry)(res);
        res.tracks = (0, caster_1.convertEntryArray)((_a = res.tracks) === null || _a === void 0 ? void 0 : _a.track);
        res.tags = (0, caster_1.convertEntryArray)((_b = res.tags) === null || _b === void 0 ? void 0 : _b.tag);
        return res;
      }
      async getTags(firstInput, usernameOrSessionKey, params) {
        let req = (0, caster_1.addConditionals)({ ...firstInput, ...params }, { user: usernameOrSessionKey });
        let res = this.convertGetTags((await this.sendRequest({ method: "album.getTags", ...req })).tags);
        return (0, caster_1.convertBasicMetaTag)(res);
      }
      async getTopTags(firstInput, params) {
        let res = (await this.sendRequest({ method: "album.getTopTags", ...firstInput, ...params })).toptags;
        return (0, caster_1.convertBasicMetaTag)(res);
      }
      async removeTag(firstInput, album, tag, sk) {
        firstInput = (0, caster_1.convertString)(firstInput, "artist", { album, tag, sk });
        return await this.sendRequest({ method: "album.removeTag", ...firstInput });
      }
      async search(firstInput, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput.limit, 1e3);
        firstInput = (0, caster_1.convertString)(firstInput, "album", {});
        let res = (await this.sendRequest({ method: "album.search", ...firstInput, ...params })).results;
        res = (0, caster_1.convertSearchWithQuery)(res);
        res.albumMatches = (0, caster_1.convertEntryArray)(res.albummatches.album);
        delete res.albummatches;
        return res;
      }
    };
    exports.default = AlbumClass;
  }
});

// node_modules/lastfm-typed/dist/classes/artist.js
var require_artist = __commonJS({
  "node_modules/lastfm-typed/dist/classes/artist.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = __importDefault(require_base());
    var caster_1 = require_caster();
    var ArtistClass = class extends base_1.default {
      async addTags(firstInput, tags, sk) {
        firstInput = (0, caster_1.convertString)(firstInput, "artist", { tags, sk });
        firstInput.tags = (0, caster_1.joinArray)(firstInput.tags);
        return await this.sendRequest({ method: "artist.addTags", ...firstInput });
      }
      async getCorrection(artist) {
        var _a, _b;
        artist = (0, caster_1.convertString)(artist, "artist", {});
        let res = ((_b = (_a = await this.sendRequest({ method: "artist.getCorrection", ...artist })) === null || _a === void 0 ? void 0 : _a.corrections) === null || _b === void 0 ? void 0 : _b.correction) || {};
        if (Object.keys(res).length) {
          res.index = (0, caster_1.toInt)(res["@attr"].index);
          delete res["@attr"];
        }
        return res;
      }
      async getInfo(firstInput, params) {
        var _a, _b, _c;
        let res = (await this.sendRequest({ method: "artist.getInfo", ...firstInput, ...params })).artist;
        res.similarArtists = (0, caster_1.toArray)((_a = res.similar) === null || _a === void 0 ? void 0 : _a.artist);
        delete res.similar;
        res.tags = (0, caster_1.toArray)((_b = res.tags) === null || _b === void 0 ? void 0 : _b.tag);
        if (res.bio) {
          res.bio.link = (_c = res.bio.links) === null || _c === void 0 ? void 0 : _c.link;
          delete res.bio.links;
        }
        res = (0, caster_1.convertEntry)(res);
        res.stats = (0, caster_1.convertEntry)(res.stats);
        return res;
      }
      async getSimilar(firstInput, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput.limit, 1e3);
        let res = (await this.sendRequest({ method: "artist.getSimilar", ...firstInput, ...params })).similarartists;
        res.meta = res["@attr"];
        delete res["@attr"];
        res.artists = (0, caster_1.convertEntryArray)(res.artist);
        delete res.artist;
        return res;
      }
      async getTags(firstInput, usernameOrSessionKey, params) {
        let req = (0, caster_1.addConditionals)({ ...firstInput, ...params }, { user: usernameOrSessionKey });
        let res = this.convertGetTags((await this.sendRequest({ method: "artist.getTags", ...req })).tags);
        return (0, caster_1.convertBasicMetaTag)(res);
      }
      async getTopAlbums(firstInput, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput.limit, 1e3);
        let res = (await this.sendRequest({ method: "artist.getTopAlbums", ...firstInput, ...params })).topalbums;
        res.albums = (0, caster_1.toArray)(res.album).filter((e) => e.name !== "(null)").map(caster_1.convertEntry);
        delete res.album;
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        return res;
      }
      async getTopTags(firstInput, params) {
        let res = (await this.sendRequest({ method: "artist.getTopTags", ...firstInput, ...params })).toptags;
        return (0, caster_1.convertBasicMetaTag)(res);
      }
      async getTopTracks(firstInput, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput.limit, 1e3);
        let res = (await this.sendRequest({ method: "artist.getTopTracks", ...firstInput, ...params })).toptracks;
        res.tracks = (0, caster_1.convertEntryArray)(res.track);
        delete res.track;
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        return res;
      }
      async removeTag(firstInput, tag, sk) {
        firstInput = (0, caster_1.convertString)(firstInput, "artist", { tag, sk });
        firstInput.tag = (0, caster_1.joinArray)(firstInput.tag);
        return await this.sendRequest({ method: "artist.removeTag", ...firstInput });
      }
      async search(firstInput, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput === null || firstInput === void 0 ? void 0 : firstInput.limit, 1e3);
        if (typeof firstInput === "string") {
          firstInput = { artist: firstInput };
        }
        let res = (await this.sendRequest({ method: "artist.search", ...firstInput, ...params })).results;
        res = (0, caster_1.convertSearchWithQuery)(res);
        res.artistMatches = (0, caster_1.convertEntryArray)(res.artistmatches.artist);
        delete res.artistmatches;
        return res;
      }
    };
    exports.default = ArtistClass;
  }
});

// node_modules/lastfm-typed/dist/classes/library.js
var require_library = __commonJS({
  "node_modules/lastfm-typed/dist/classes/library.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = __importDefault(require_base());
    var caster_1 = require_caster();
    var LibraryClass = class extends base_1.default {
      async getArtists(firstInput, params) {
        var _a;
        firstInput = (0, caster_1.convertString)(firstInput, "user", {});
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput === null || firstInput === void 0 ? void 0 : firstInput.limit, 1e3);
        let res = (await this.sendRequest({ method: "library.getArtists", ...firstInput, ...params })).artists;
        return (0, caster_1.convertExtendedMeta)(res, "artist");
      }
    };
    exports.default = LibraryClass;
  }
});

// node_modules/lastfm-typed/dist/classes/track.js
var require_track = __commonJS({
  "node_modules/lastfm-typed/dist/classes/track.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = __importDefault(require_base());
    var caster_1 = require_caster();
    var TrackClass = class extends base_1.default {
      async addTags(artist, track, tags, sk) {
        artist = (0, caster_1.convertString)(artist, "artist", { track, tags, sk });
        artist.tags = (0, caster_1.joinArray)(artist.tags);
        return await this.sendRequest({ method: "track.addTags", ...artist });
      }
      async getCorrection(artist, track) {
        var _a, _b;
        artist = (0, caster_1.convertString)(artist, "artist", { track });
        let res = ((_b = (_a = await this.sendRequest({ method: "track.getCorrection", ...artist })) === null || _a === void 0 ? void 0 : _a.corrections) === null || _b === void 0 ? void 0 : _b.correction) || {};
        if (!res.track.hasOwnProperty("name")) {
          res = {};
        }
        if (Object.keys(res).length) {
          res.meta = (0, caster_1.convertMeta)(res["@attr"]);
          delete res["@attr"];
        }
        return res;
      }
      async getInfo(track, params) {
        var _a, _b;
        let res = (await this.sendRequest({ method: "track.getInfo", ...track, ...params })).track;
        res.toptags = (0, caster_1.toArray)((_a = res.toptags) === null || _a === void 0 ? void 0 : _a.tag);
        res = (0, caster_1.convertEntry)(res);
        if (res.album) {
          if (res.album["@attr"]) {
            res.album.position = (0, caster_1.toInt)((_b = res.album["@attr"]) === null || _b === void 0 ? void 0 : _b.position);
            delete res.album["@attr"];
          }
          res.album.image = (0, caster_1.convertImageArray)(res.album.image);
        }
        return res;
      }
      async getSimilar(track, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : track === null || track === void 0 ? void 0 : track.limit, 1e3);
        let res = (await this.sendRequest({ method: "track.getSimilar", ...track, ...params })).similartracks;
        return (0, caster_1.convertExtendedMeta)(res, "track");
      }
      async getTags(track, username, params) {
        track = (0, caster_1.addConditionals)(track, { username });
        let res = this.convertGetTags((await this.sendRequest({ method: "track.getTags", ...track, ...params })).tags);
        return (0, caster_1.convertBasicMetaTag)(res);
      }
      async getTopTags(track, params) {
        let res = (await this.sendRequest({ method: "track.getTopTags", ...track, ...params })).toptags;
        return (0, caster_1.convertBasicMetaTag)(res);
      }
      async love(artist, track, sk) {
        artist = (0, caster_1.convertString)(artist, "artist", { track, sk });
        return await this.sendRequest({ method: "track.love", ...artist });
      }
      async removeTag(artist, track, tag, sk) {
        artist = (0, caster_1.convertString)(artist, "artist", { track, sk, tag });
        return await this.sendRequest({ method: "track.removeTag", ...artist });
      }
      async scrobble(firstInput, scrobbles) {
        firstInput = (0, caster_1.convertString)(firstInput, "sk", { scrobbles });
        this.checkScrobbleCount(firstInput.scrobbles.length, 50);
        let params = {};
        for (let [index, scrobble] of firstInput.scrobbles.entries()) {
          for (let [key, value] of Object.entries(scrobble)) {
            if (value === void 0) {
              continue;
            }
            if (key === "chosenByUser") {
              params[`${key}[${index}]`] = (0, caster_1.boolToInt)(value);
            } else {
              params[`${key}[${index}]`] = value;
            }
          }
        }
        let res = (await this.sendRequest({ method: "track.scrobble", ...params, sk: firstInput.sk })).scrobbles;
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        res.scrobbles = (0, caster_1.toArray)(res.scrobble).map((e) => {
          e.ignoredMessage.message = e.ignoredMessage["#text"];
          delete e.ignoredMessage["#text"];
          if (e.artist["#text"]) {
            e.artist.name = e.artist["#text"];
            delete e.artist["#text"];
          }
          if (e.album["#text"]) {
            e.album.name = e.album["#text"];
            delete e.album["#text"];
          }
          if (e.track["#text"]) {
            e.track.name = e.track["#text"];
            delete e.track["#text"];
          }
          if (e.albumArtist["#text"]) {
            e.albumArtist.name = e.albumArtist["#text"];
            delete e.albumArtist["#text"];
          }
          e.artist.corrected = (0, caster_1.toBool)(e.artist.corrected);
          e.album.corrected = (0, caster_1.toBool)(e.album.corrected);
          e.albumArtist.corrected = (0, caster_1.toBool)(e.albumArtist.corrected);
          e.track.corrected = (0, caster_1.toBool)(e.track.corrected);
          e.ignoredMessage.code = (0, caster_1.toInt)(e.ignoredMessage.code);
          e.timestamp = (0, caster_1.toInt)(e.timestamp);
          return e;
        });
        delete res.scrobble;
        return res;
      }
      async search(track, params) {
        var _a;
        track = (0, caster_1.convertString)(track, "track", {});
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : track === null || track === void 0 ? void 0 : track.limit, 1e3);
        let res = (await this.sendRequest({ method: "track.search", ...track, ...params })).results;
        res = (0, caster_1.convertSearch)(res);
        res.trackMatches = (0, caster_1.convertEntryArray)(res.trackmatches.track);
        delete res.trackmatches;
        return res;
      }
      async unlove(artist, track, sk) {
        artist = (0, caster_1.convertString)(artist, "artist", { track, sk });
        return await this.sendRequest({ method: "track.unlove", ...artist });
      }
      async updateNowPlaying(artist, track, sk, params) {
        artist = (0, caster_1.convertString)(artist, "artist", { track, sk });
        return await this.sendRequest({ method: "track.updateNowPlaying", ...artist, ...params });
      }
    };
    exports.default = TrackClass;
  }
});

// node_modules/lastfm-typed/dist/classes/user.js
var require_user = __commonJS({
  "node_modules/lastfm-typed/dist/classes/user.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = __importDefault(require_base());
    var caster_1 = require_caster();
    var UserClass = class extends base_1.default {
      async getFriends(firstInput, params) {
        firstInput = this.checkLimitAndConvertString(firstInput, params);
        let res = (await this.sendRequest({ method: "user.getFriends", ...firstInput, ...params })).friends;
        res.users = (0, caster_1.toArray)(res.user).map((e) => {
          e = (0, caster_1.setDate)(e, "registered");
          e = (0, caster_1.convertEntry)(e);
          return e;
        });
        delete res.user;
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        return res;
      }
      async getInfo(firstInput, params) {
        firstInput = (0, caster_1.convertString)(firstInput, "user", {});
        let res = (await this.sendRequest({ method: "user.getInfo", ...firstInput, ...params })).user;
        res.registered = (0, caster_1.toInt)(res.registered.unixtime);
        res = (0, caster_1.convertEntry)(res);
        return res;
      }
      async getLovedTracks(firstInput, params) {
        firstInput = this.checkLimitAndConvertString(firstInput, params);
        let res = (await this.sendRequest({ method: "user.getLovedTracks", ...firstInput, ...params })).lovedtracks;
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        res.tracks = (0, caster_1.toArray)(res.track).map((e) => {
          e = (0, caster_1.setDate)(e, "date");
          e = (0, caster_1.convertEntry)(e);
          return e;
        });
        delete res.track;
        return res;
      }
      async getPersonalTags(firstInput, tag, taggingType, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput === null || firstInput === void 0 ? void 0 : firstInput.limit, 1e3);
        firstInput = (0, caster_1.convertString)(firstInput, "user", { tag, taggingType });
        let res = (await this.sendRequest({ method: "user.getPersonalTags", ...firstInput, ...params })).taggings;
        if (res.hasOwnProperty("artists")) {
          res.artists = (0, caster_1.convertEntryArray)(res.artists.artist);
        } else if (res.hasOwnProperty("albums")) {
          res.albums = (0, caster_1.convertEntryArray)(res.albums.album);
        } else if (res.hasOwnProperty("tracks")) {
          res.tracks = (0, caster_1.convertEntryArray)(res.tracks.track);
        }
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        return res;
      }
      async getRecentTracks(firstInput, params) {
        var _a;
        firstInput = this.checkLimitAndConvertString(firstInput, params);
        if (params === null || params === void 0 ? void 0 : params.hasOwnProperty("extended")) {
          params.extended = (_a = (0, caster_1.toInt)(params.extended)) !== null && _a !== void 0 ? _a : 0;
        } else if (firstInput === null || firstInput === void 0 ? void 0 : firstInput.hasOwnProperty("extended")) {
          firstInput.extended = (0, caster_1.toInt)(firstInput.extended);
        }
        let res = (await this.sendRequest({ method: "user.getRecentTracks", ...firstInput, ...params })).recenttracks;
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        res.tracks = (0, caster_1.convertGetRecentTracks)(res.track);
        delete res.track;
        return res;
      }
      async getTopAlbums(firstInput, params) {
        firstInput = this.checkLimitAndConvertString(firstInput, params);
        let res = (await this.sendRequest({ method: "user.getTopAlbums", ...firstInput, ...params })).topalbums;
        return (0, caster_1.convertExtendedMeta)(res, "album");
      }
      async getTopArtists(firstInput, params) {
        firstInput = this.checkLimitAndConvertString(firstInput, params);
        let res = (await this.sendRequest({ method: "user.getTopArtists", ...firstInput, ...params })).topartists;
        return (0, caster_1.convertExtendedMeta)(res, "artist");
      }
      async getTopTags(firstInput, params) {
        firstInput = this.checkLimitAndConvertString(firstInput, params);
        let res = (await this.sendRequest({ method: "user.getTopTags", ...firstInput, ...params })).toptags;
        return (0, caster_1.convertExtendedMeta)(res, "tag");
      }
      async getTopTracks(firstInput, params) {
        firstInput = this.checkLimitAndConvertString(firstInput, params);
        let res = (await this.sendRequest({ method: "user.getTopTracks", ...firstInput, ...params })).toptracks;
        return (0, caster_1.convertExtendedMeta)(res, "track");
      }
      async getWeeklyAlbumChart(firstInput, params) {
        firstInput = this.checkLimitAndConvertString(firstInput, params);
        let res = (await this.sendRequest({ method: "user.getWeeklyAlbumChart", ...firstInput, ...params })).weeklyalbumchart;
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        res.albums = (0, caster_1.toArray)(res.album).map((e) => {
          e.artist.name = e.artist["#text"];
          delete e.artist["#text"];
          e = (0, caster_1.convertEntry)(e);
          return e;
        });
        delete res.album;
        return res;
      }
      async getWeeklyArtistChart(firstInput, params) {
        firstInput = this.checkLimitAndConvertString(firstInput, params);
        let res = (await this.sendRequest({ method: "user.getWeeklyArtistChart", ...firstInput, ...params })).weeklyartistchart;
        return (0, caster_1.convertExtendedMeta)(res, "artist");
      }
      async getWeeklyChartList(input) {
        let res = (await this.sendRequest({ method: "user.getWeeklyChartList" })).weeklychartlist;
        res.charts = (0, caster_1.toArray)(res.chart).map(caster_1.convertMeta);
        delete res.chart;
        return res;
      }
      async getWeeklyTrackChart(firstInput, params) {
        firstInput = this.checkLimitAndConvertString(firstInput, params);
        let res = (await this.sendRequest({ method: "user.getWeeklyTrackChart", ...firstInput, ...params })).weeklytrackchart;
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        res.tracks = (0, caster_1.toArray)(res.track).map((e) => {
          e.artist.name = e.artist["#text"];
          delete e.artist["#text"];
          e = (0, caster_1.convertEntry)(e);
          return e;
        });
        delete res.track;
        return res;
      }
      checkLimitAndConvertString(firstInput, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput === null || firstInput === void 0 ? void 0 : firstInput.limit, 1e3);
        return (0, caster_1.convertString)(firstInput, "user", {});
      }
    };
    exports.default = UserClass;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/lastfm-typed/dist/classes/helper.js
var require_helper = __commonJS({
  "node_modules/lastfm-typed/dist/classes/helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require_events();
    var caster_1 = require_caster();
    var HelperClass = class {
      constructor(lastfm) {
        this.ArtistFromMBID = (mbid) => ({ mbid });
        this.ArtistFromName = (artist) => ({ artist });
        this.AlbumFromMBID = (mbid) => ({ mbid });
        this.AlbumFromName = (artist, album) => ({ artist, album });
        this.TrackFromMBID = (mbid) => ({ mbid });
        this.TrackFromName = (artist, track) => ({ artist, track });
        this.lastfm = lastfm;
      }
      async getCombo(firstInput, limit) {
        var _a;
        firstInput = (0, caster_1.convertString)(firstInput, "user", { limit: Math.min(1e3, limit !== null && limit !== void 0 ? limit : 200) });
        let combo = [true, true, true];
        let comboData = [["", 0], ["", 0], ["", 0]];
        let page = 0;
        let nowplaying = false;
        let trueLimit = 1e3;
        let image = [];
        while (firstInput.limit > 0 && combo[0] === combo[1] && combo[1] === combo[2] && combo[2] === true) {
          if (firstInput.limit < 1e3 && page > 0) {
            trueLimit = firstInput.limit;
            limit = 1e3;
          } else if (page === 0 && firstInput.limit <= 1e3) {
            trueLimit = firstInput.limit;
          }
          page++;
          let res = await this.lastfm.user.getRecentTracks({ ...firstInput, page });
          if (page === 1) {
            comboData[0][0] = res.tracks[0].artist.name;
            comboData[1][0] = res.tracks[0].album.name;
            comboData[2][0] = res.tracks[0].name;
            image = res.tracks[0].image;
            if (comboData[1][0] === "") {
              combo[1] = false;
            }
          }
          if ((_a = res.tracks[0]) === null || _a === void 0 ? void 0 : _a.nowplaying) {
            nowplaying = true;
            res.tracks = res.tracks.slice(1);
          }
          for (let i = 0; i < trueLimit; i++) {
            if (!combo[0] && !combo[1] && !combo[2]) {
              break;
            }
            if (combo[0]) {
              if (comboData[0][0] === res.tracks[Number(i)].artist.name) {
                comboData[0][1]++;
              } else {
                combo[0] = false;
              }
            }
            if (combo[1]) {
              if (comboData[1][0] === res.tracks[Number(i)].album.name) {
                comboData[1][1]++;
              } else {
                combo[1] = false;
              }
            }
            if (combo[2]) {
              if (comboData[2][0] === res.tracks[Number(i)].name) {
                comboData[2][1]++;
              } else {
                combo[2] = false;
              }
            }
          }
        }
        return {
          artist: {
            name: comboData[0][0],
            combo: comboData[0][1]
          },
          album: {
            name: comboData[1][0],
            combo: comboData[1][1]
          },
          track: {
            name: comboData[2][0],
            combo: comboData[2][1]
          },
          nowplaying,
          image
        };
      }
      async getNowPlaying(firstInput, detailTypes = [], params = { extended: true }) {
        var _a;
        firstInput = (0, caster_1.convertString)(firstInput, "user", { detailTypes, ...params });
        firstInput = this.homogenizeUserInput(firstInput);
        const curr = await this.lastfm.user.getRecentTracks(firstInput.user, { limit: 1, extended: firstInput.extended });
        const currTrack = curr.tracks[0];
        const artist = currTrack.artist.name;
        const track = currTrack.name;
        const image = currTrack.image;
        const album = (_a = currTrack.album) === null || _a === void 0 ? void 0 : _a.name;
        const url = currTrack.url;
        const username = curr.meta.user;
        const nowplaying = currTrack === null || currTrack === void 0 ? void 0 : currTrack.nowplaying;
        const details = {
          recent: {
            data: curr
          },
          artist: {
            successful: false
          },
          album: {
            successful: false
          },
          track: {
            successful: false
          }
        };
        if (firstInput.detailTypes) {
          const res = await this.fetchDetails(firstInput.user, firstInput.detailTypes, artist, album, track);
          const exists = res.map((e) => typeof e !== "undefined" && typeof e.error === "undefined");
          let i = 0;
          if (firstInput.detailTypes.includes("artist")) {
            details.artist.data = res[i];
            details.artist.successful = exists[i];
            i++;
          }
          if (firstInput.detailTypes.includes("album") && album) {
            details.album.data = res[i];
            details.album.successful = exists[i];
            i++;
          }
          if (firstInput.detailTypes.includes("track")) {
            details.track.data = res[i];
            details.track.successful = exists[i];
            i++;
          }
          return {
            recent: {
              artist,
              album,
              track,
              image,
              url,
              username,
              nowplaying
            },
            details
          };
        }
        return {
          recent: {
            artist,
            album,
            track,
            image,
            url,
            username,
            nowplaying
          },
          details: {
            recent: {
              data: curr
            },
            artist: {
              successful: false
            },
            album: {
              successful: false
            },
            track: {
              successful: false
            }
          }
        };
      }
      async getMatchingArtists(firstInput, user2, limit, period) {
        firstInput = (0, caster_1.convertString)(firstInput, "user1", { user2, limit, period });
        this.checkLimit(firstInput.limit, 1e3);
        let request = [
          this.lastfm.user.getTopArtists(firstInput.user1, { limit: firstInput.limit, period: firstInput.period }),
          this.lastfm.user.getTopArtists(firstInput.user2, { limit: firstInput.limit, period: firstInput.period })
        ];
        const res = await Promise.all(request);
        return this.getIntersection(res[0].artists, res[1].artists);
      }
      cacheScrobbles(user, params) {
        params !== null && params !== void 0 ? params : params = {};
        if (typeof user !== "string") {
          params.previouslyCached = user.previouslyCached;
          params.parallelCaches = user.parallelCaches;
          params.rateLimitTimeout = user.rateLimitTimeout;
          user = user.user;
        }
        let scrobbleEmitter = new events_1.EventEmitter();
        this.handleCaching(user, scrobbleEmitter, params);
        return scrobbleEmitter;
      }
      async handleCaching(user, scrobbleEmitter, params) {
        let count;
        try {
          count = (await this.lastfm.user.getRecentTracks(user, { limit: 1 })).meta.total;
        } catch {
          let rateLimitInterval = setInterval(() => {
            try {
              this.handleCaching(user, scrobbleEmitter, params);
              clearInterval(rateLimitInterval);
            } catch (err) {
            }
          });
          return;
        }
        let newCount = count - ((params === null || params === void 0 ? void 0 : params.previouslyCached) || 0);
        let totalPages = Math.ceil(newCount / 1e3);
        let rateLimited = false;
        let limitTime = (params === null || params === void 0 ? void 0 : params.rateLimitTimeout) || 3e5;
        scrobbleEmitter.emit("start", { totalPages, count: newCount });
        let pages = Array(totalPages).fill("").map((_, i) => i + 1);
        let active = Math.min((params === null || params === void 0 ? void 0 : params.parallelCaches) || 1, totalPages);
        let complete = 0;
        this.attemptClose(active, scrobbleEmitter);
        for (let currPage = 1; currPage <= active; currPage++) {
          pages.shift();
          this.handleCacheInstance(user, scrobbleEmitter, currPage, newCount);
        }
        scrobbleEmitter.on("internalDontUse", (data) => {
          if (typeof data !== "number") {
            complete++;
            let data2 = data;
            if (data2.meta.page === totalPages) {
              data2.tracks = data2.tracks.slice(0, newCount % 1e3);
            }
            scrobbleEmitter.emit("data", { data: data2, completedPages: complete, totalPages, progress: complete / totalPages });
            if (pages.length) {
              if (!rateLimited) {
                this.handleCacheInstance(user, scrobbleEmitter, pages[0], newCount);
                pages.shift();
              } else {
                let rateLimitInterval = setInterval(() => {
                  if (!rateLimited) {
                    this.handleCacheInstance(user, scrobbleEmitter, pages[0], newCount);
                    pages.shift();
                    clearInterval(rateLimitInterval);
                  }
                });
              }
            } else {
              active--;
              this.attemptClose(active, scrobbleEmitter);
            }
          } else {
            if (!rateLimited) {
              this.handleCacheInstance(user, scrobbleEmitter, data, newCount);
            } else {
              let rateLimitInterval = setInterval(() => {
                if (!rateLimited) {
                  this.handleCacheInstance(user, scrobbleEmitter, data, newCount);
                  clearInterval(rateLimitInterval);
                }
              });
            }
          }
        });
        scrobbleEmitter.on("error", (err, page) => {
          if ((0, caster_1.toInt)(err.code) === 29) {
            rateLimited = true;
            setTimeout(() => {
              rateLimited = false;
            }, limitTime);
          }
          scrobbleEmitter.emit("internalDontUse", page);
        });
      }
      attemptClose(active, scrobbleEmitter) {
        if (active === 0) {
          scrobbleEmitter.emit("close");
          scrobbleEmitter.removeAllListeners();
        }
      }
      async handleCacheInstance(user, scrobbleEmitter, page, count) {
        var _a;
        try {
          let res = await this.lastfm.user.getRecentTracks(user, { limit: 1e3, page });
          if (res.tracks[0].nowplaying) {
            (_a = res === null || res === void 0 ? void 0 : res.tracks) === null || _a === void 0 ? void 0 : _a.shift();
          }
          scrobbleEmitter.emit("internalDontUse", res);
        } catch (err) {
          if (typeof err === "object" && err !== null && err.hasOwnProperty("code") && err.hasOwnProperty("message")) {
            scrobbleEmitter.emit("error", {
              code: Number(err.code),
              message: err.message
            }, page);
          } else {
            scrobbleEmitter.emit("error", {
              code: 41,
              message: `An unknown error occurred. Details: ${err}`
            }, page);
          }
        }
      }
      getIntersection(arr1, arr2) {
        const aSort = arr1.sort((a, b) => a.name.localeCompare(b.name));
        const bSort = arr2.sort((a, b) => a.name.localeCompare(b.name));
        let i1 = 0;
        let i2 = 0;
        let common = [];
        while (i1 < aSort.length && i2 < bSort.length) {
          const compare = aSort[i1].name.localeCompare(bSort[i2].name);
          if (compare === 0) {
            common.push({
              name: aSort[i1].name,
              url: aSort[i1].url,
              playcount: [aSort[i1].playcount, bSort[i2].playcount]
            });
            i1++;
            i2++;
          } else {
            i1 += +(compare < 0);
            i2 += +(compare > 0);
          }
        }
        return common;
      }
      checkLimit(limit, maxLimit) {
        if (typeof limit !== "undefined" && (limit > maxLimit || limit < 1)) {
          throw new Error(`Limit out of bounds (1-${maxLimit}), ${limit} passed`);
        }
      }
      async fetchDetails(username, detailTypes, artist, album, track, params) {
        let promises = [];
        let options = {
          username
        };
        if (params === null || params === void 0 ? void 0 : params.sk) {
          options.sk = params.sk;
        }
        if (detailTypes === null || detailTypes === void 0 ? void 0 : detailTypes.includes("artist")) {
          promises.push(this.lastfm.artist.getInfo({ artist }, options).catch((err) => {
          }));
        }
        if ((detailTypes === null || detailTypes === void 0 ? void 0 : detailTypes.includes("album")) && album) {
          promises.push(this.lastfm.album.getInfo({ artist, album }, options).catch((err) => {
          }));
        }
        if (detailTypes === null || detailTypes === void 0 ? void 0 : detailTypes.includes("track")) {
          promises.push(this.lastfm.track.getInfo({ artist, track }, options).catch((err) => {
          }));
        }
        return await Promise.all(promises);
      }
      homogenizeUserInput(input) {
        if (input.hasOwnProperty("user")) {
          return input;
        }
        for (let userInput of ["username", "sk", "usernameOrSessionKey"]) {
          if (input.hasOwnProperty(userInput)) {
            input.user = input[userInput];
            delete input[userInput];
          }
        }
        throw "No valid user input";
      }
    };
    exports.default = HelperClass;
  }
});

// node_modules/lastfm-typed/dist/logger.js
var require_logger = __commonJS({
  "node_modules/lastfm-typed/dist/logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LoggerClass = class {
      constructor(lastfm) {
        this.lastfm = lastfm;
      }
      emitRequest(args, HTTPMethod) {
        this.lastfm.emit("requestStart", args, HTTPMethod);
      }
      emitRequestComplete(args, time, res) {
        this.lastfm.emit("requestComplete", args, time, res);
      }
    };
    exports.default = LoggerClass;
  }
});

// node_modules/lastfm-typed/dist/classes/geo.js
var require_geo = __commonJS({
  "node_modules/lastfm-typed/dist/classes/geo.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = __importDefault(require_base());
    var caster_1 = require_caster();
    var GeoClass = class extends base_1.default {
      async getTopArtists(firstInput, params) {
        firstInput = (0, caster_1.convertString)(firstInput, "country", {});
        let res = (await this.getTop("geo.getTopArtists", firstInput, params)).topartists;
        return (0, caster_1.convertExtendedMeta)(res, "artist");
      }
      async getTopTracks(firstInput, params) {
        firstInput = (0, caster_1.convertString)(firstInput, "country", {});
        let res = (await this.getTop("geo.getTopTracks", firstInput, params)).tracks;
        return (0, caster_1.convertExtendedMeta)(res, "track");
      }
      async getTop(method, firstInput, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput === null || firstInput === void 0 ? void 0 : firstInput.limit, 1e3);
        return await this.sendRequest({ method, ...firstInput, ...params });
      }
    };
    exports.default = GeoClass;
  }
});

// node_modules/lastfm-typed/dist/index.js
var require_dist = __commonJS({
  "node_modules/lastfm-typed/dist/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var tag_1 = __importDefault(require_tag());
    var chart_1 = __importDefault(require_chart());
    var auth_1 = __importDefault(require_auth());
    var album_1 = __importDefault(require_album());
    var artist_1 = __importDefault(require_artist());
    var library_1 = __importDefault(require_library());
    var track_1 = __importDefault(require_track());
    var user_1 = __importDefault(require_user());
    var helper_1 = __importDefault(require_helper());
    var logger_1 = __importDefault(require_logger());
    var events_1 = require_events();
    var geo_1 = __importDefault(require_geo());
    var LastFM = class extends events_1.EventEmitter {
      constructor(apiKey, options) {
        var _a, _b, _c;
        super();
        if (!options) {
          options = {};
        }
        (_a = options.apiSecret) !== null && _a !== void 0 ? _a : options.apiSecret = "";
        (_b = options.userAgent) !== null && _b !== void 0 ? _b : options.userAgent = "lastfm-typed-npm";
        (_c = options.secureConnection) !== null && _c !== void 0 ? _c : options.secureConnection = true;
        let { apiSecret, userAgent, secureConnection } = options;
        this.info = {
          key: apiKey,
          secret: apiSecret,
          context: this
        };
        this.tag = new tag_1.default(apiKey, this, apiSecret, userAgent, secureConnection);
        this.chart = new chart_1.default(apiKey, this, apiSecret, userAgent, secureConnection);
        this.geo = new geo_1.default(apiKey, this, apiSecret, userAgent, secureConnection);
        this.auth = new auth_1.default(apiKey, this, apiSecret, userAgent, secureConnection);
        this.album = new album_1.default(apiKey, this, apiSecret, userAgent, secureConnection);
        this.artist = new artist_1.default(apiKey, this, apiSecret, userAgent, secureConnection);
        this.library = new library_1.default(apiKey, this, apiSecret, userAgent, secureConnection);
        this.track = new track_1.default(apiKey, this, apiSecret, userAgent, secureConnection);
        this.user = new user_1.default(apiKey, this, apiSecret, userAgent, secureConnection);
        this.helper = new helper_1.default(this);
        this.logger = new logger_1.default(this);
      }
    };
    exports.default = LastFM;
  }
});

// dep:lastfm-typed
var lastfm_typed_default = require_dist();
export {
  lastfm_typed_default as default
};
//# sourceMappingURL=lastfm-typed.js.map
