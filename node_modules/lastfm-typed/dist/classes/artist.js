"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __importDefault(require("../base"));
const caster_1 = require("../caster");
class ArtistClass extends base_1.default {
    async addTags(firstInput, tags, sk) {
        firstInput = (0, caster_1.convertString)(firstInput, "artist", { tags, sk });
        firstInput.tags = (0, caster_1.joinArray)(firstInput.tags);
        return await this.sendRequest({ method: "artist.addTags", ...firstInput });
    }
    async getCorrection(artist) {
        var _a, _b;
        artist = (0, caster_1.convertString)(artist, "artist", {});
        let res = (((_b = (_a = (await this.sendRequest({ method: "artist.getCorrection", ...artist }))) === null || _a === void 0 ? void 0 : _a.corrections) === null || _b === void 0 ? void 0 : _b.correction) || {});
        if (Object.keys(res).length) {
            res.index = (0, caster_1.toInt)(res["@attr"].index);
            delete res["@attr"];
        }
        return res;
    }
    async getInfo(firstInput, params) {
        var _a, _b, _c;
        let res = (await this.sendRequest({ method: "artist.getInfo", ...firstInput, ...params })).artist;
        res.similarArtists = (0, caster_1.toArray)((_a = res.similar) === null || _a === void 0 ? void 0 : _a.artist);
        delete res.similar;
        res.tags = (0, caster_1.toArray)((_b = res.tags) === null || _b === void 0 ? void 0 : _b.tag);
        if (res.bio) {
            res.bio.link = (_c = res.bio.links) === null || _c === void 0 ? void 0 : _c.link;
            delete res.bio.links;
        }
        res = (0, caster_1.convertEntry)(res);
        res.stats = (0, caster_1.convertEntry)(res.stats);
        return res;
    }
    async getSimilar(firstInput, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput.limit, 1000);
        let res = (await this.sendRequest({ method: "artist.getSimilar", ...firstInput, ...params })).similarartists;
        res.meta = res["@attr"];
        delete res["@attr"];
        res.artists = (0, caster_1.convertEntryArray)(res.artist);
        delete res.artist;
        return res;
    }
    async getTags(firstInput, usernameOrSessionKey, params) {
        let req = (0, caster_1.addConditionals)({ ...firstInput, ...params }, { user: usernameOrSessionKey });
        let res = this.convertGetTags((await this.sendRequest({ method: "artist.getTags", ...req })).tags);
        return (0, caster_1.convertBasicMetaTag)(res);
    }
    async getTopAlbums(firstInput, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput.limit, 1000);
        let res = (await this.sendRequest({ method: "artist.getTopAlbums", ...firstInput, ...params })).topalbums;
        res.albums = (0, caster_1.toArray)(res.album).filter((e) => e.name !== "(null)").map(caster_1.convertEntry);
        delete res.album;
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        return res;
    }
    async getTopTags(firstInput, params) {
        let res = (await this.sendRequest({ method: "artist.getTopTags", ...firstInput, ...params })).toptags;
        return (0, caster_1.convertBasicMetaTag)(res);
    }
    async getTopTracks(firstInput, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput.limit, 1000);
        let res = (await this.sendRequest({ method: "artist.getTopTracks", ...firstInput, ...params })).toptracks;
        res.tracks = (0, caster_1.convertEntryArray)(res.track);
        delete res.track;
        res.meta = (0, caster_1.convertMeta)(res["@attr"]);
        delete res["@attr"];
        return res;
    }
    async removeTag(firstInput, tag, sk) {
        firstInput = (0, caster_1.convertString)(firstInput, "artist", { tag, sk });
        firstInput.tag = (0, caster_1.joinArray)(firstInput.tag);
        return await this.sendRequest({ method: "artist.removeTag", ...firstInput });
    }
    async search(firstInput, params) {
        var _a;
        this.checkLimit((_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : firstInput === null || firstInput === void 0 ? void 0 : firstInput.limit, 1000);
        if (typeof firstInput === "string") {
            firstInput = { artist: firstInput };
        }
        let res = (await this.sendRequest({ method: "artist.search", ...firstInput, ...params })).results;
        res = (0, caster_1.convertSearchWithQuery)(res);
        res.artistMatches = (0, caster_1.convertEntryArray)(res.artistmatches.artist);
        delete res.artistmatches;
        return res;
    }
}
exports.default = ArtistClass;
//# sourceMappingURL=artist.js.map